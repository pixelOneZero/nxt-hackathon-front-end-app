{"ast":null,"code":"import { RealtimeEventHandler } from './event_handler.js';\nimport { RealtimeAPI } from './api.js';\nimport { RealtimeConversation } from './conversation.js';\nimport { RealtimeUtils } from './utils.js';\n\n/**\n * Valid audio formats\n * @typedef {\"pcm16\"|\"g711-ulaw\"|\"g711-alaw\"} AudioFormatType\n */\n\n/**\n * @typedef {Object} AudioTranscriptionType\n * @property {boolean} [enabled]\n * @property {\"whisper-1\"} model\n */\n\n/**\n * @typedef {Object} TurnDetectionServerVadType\n * @property {\"server_vad\"} type\n * @property {number} [threshold]\n * @property {number} [prefix_padding_ms]\n * @property {number} [silence_duration_ms]\n */\n\n/**\n * Tool definitions\n * @typedef {Object} ToolDefinitionType\n * @property {\"function\"} [type]\n * @property {string} name\n * @property {string} description\n * @property {{[key: string]: any}} parameters\n */\n\n/**\n * @typedef {Object} SessionResourceType\n * @property {string} [model]\n * @property {string[]} [modalities]\n * @property {string} [instructions]\n * @property {\"alloy\"|\"shimmer\"|\"echo\"} [voice]\n * @property {AudioFormatType} [input_audio_format]\n * @property {AudioFormatType} [output_audio_format]\n * @property {AudioTranscriptionType|null} [input_audio_transcription]\n * @property {TurnDetectionServerVadType|null} [turn_detection]\n * @property {ToolDefinitionType[]} [tools]\n * @property {\"auto\"|\"none\"|\"required\"|{type:\"function\",name:string}} [tool_choice]\n * @property {number} [temperature]\n * @property {number|\"inf\"} [max_response_output_tokens]\n */\n\n/**\n * @typedef {\"in_progress\"|\"completed\"|\"incomplete\"} ItemStatusType\n */\n\n/**\n * @typedef {Object} InputTextContentType\n * @property {\"input_text\"} type\n * @property {string} text\n */\n\n/**\n * @typedef {Object} InputAudioContentType\n * @property {\"input_audio\"} type\n * @property {string} [audio] base64-encoded audio data\n * @property {string|null} [transcript]\n */\n\n/**\n * @typedef {Object} TextContentType\n * @property {\"text\"} type\n * @property {string} text\n */\n\n/**\n * @typedef {Object} AudioContentType\n * @property {\"audio\"} type\n * @property {string} [audio] base64-encoded audio data\n * @property {string|null} [transcript]\n */\n\n/**\n * @typedef {Object} SystemItemType\n * @property {string|null} [previous_item_id]\n * @property {\"message\"} type\n * @property {ItemStatusType} status\n * @property {\"system\"} role\n * @property {Array<InputTextContentType>} content\n */\n\n/**\n * @typedef {Object} UserItemType\n * @property {string|null} [previous_item_id]\n * @property {\"message\"} type\n * @property {ItemStatusType} status\n * @property {\"system\"} role\n * @property {Array<InputTextContentType|InputAudioContentType>} content\n */\n\n/**\n * @typedef {Object} AssistantItemType\n * @property {string|null} [previous_item_id]\n * @property {\"message\"} type\n * @property {ItemStatusType} status\n * @property {\"assistant\"} role\n * @property {Array<TextContentType|AudioContentType>} content\n */\n\n/**\n * @typedef {Object} FunctionCallItemType\n * @property {string|null} [previous_item_id]\n * @property {\"function_call\"} type\n * @property {ItemStatusType} status\n * @property {string} call_id\n * @property {string} name\n * @property {string} arguments\n */\n\n/**\n * @typedef {Object} FunctionCallOutputItemType\n * @property {string|null} [previous_item_id]\n * @property {\"function_call_output\"} type\n * @property {string} call_id\n * @property {string} output\n */\n\n/**\n * @typedef {Object} FormattedToolType\n * @property {\"function\"} type\n * @property {string} name\n * @property {string} call_id\n * @property {string} arguments\n */\n\n/**\n * @typedef {Object} FormattedPropertyType\n * @property {Int16Array} [audio]\n * @property {string} [text]\n * @property {string} [transcript]\n * @property {FormattedToolType} [tool]\n * @property {string} [output]\n * @property {any} [file]\n */\n\n/**\n * @typedef {Object} FormattedItemType\n * @property {string} id\n * @property {string} object\n * @property {\"user\"|\"assistant\"|\"system\"} [role]\n * @property {FormattedPropertyType} formatted\n */\n\n/**\n * @typedef {SystemItemType|UserItemType|AssistantItemType|FunctionCallItemType|FunctionCallOutputItemType} BaseItemType\n */\n\n/**\n * @typedef {FormattedItemType & BaseItemType} ItemType\n */\n\n/**\n * @typedef {Object} IncompleteResponseStatusType\n * @property {\"incomplete\"} type\n * @property {\"interruption\"|\"max_output_tokens\"|\"content_filter\"} reason\n */\n\n/**\n * @typedef {Object} FailedResponseStatusType\n * @property {\"failed\"} type\n * @property {{code: string, message: string}|null} error\n */\n\n/**\n * @typedef {Object} UsageType\n * @property {number} total_tokens\n * @property {number} input_tokens\n * @property {number} output_tokens\n */\n\n/**\n * @typedef {Object} ResponseResourceType\n * @property {\"in_progress\"|\"completed\"|\"incomplete\"|\"cancelled\"|\"failed\"} status\n * @property {IncompleteResponseStatusType|FailedResponseStatusType|null} status_details\n * @property {ItemType[]} output\n * @property {UsageType|null} usage\n */\n\n/**\n * RealtimeClient Class\n * @class\n */\nexport class RealtimeClient extends RealtimeEventHandler {\n  /**\n   * Create a new RealtimeClient instance\n   * @param {{url?: string, apiKey?: string, dangerouslyAllowAPIKeyInBrowser?: boolean, debug?: boolean}} [settings]\n   */\n  constructor({\n    url,\n    apiKey,\n    dangerouslyAllowAPIKeyInBrowser,\n    debug\n  } = {}) {\n    super();\n    this.defaultSessionConfig = {\n      modalities: ['text', 'audio'],\n      instructions: '',\n      voice: 'alloy',\n      input_audio_format: 'pcm16',\n      output_audio_format: 'pcm16',\n      input_audio_transcription: null,\n      turn_detection: null,\n      tools: [],\n      tool_choice: 'auto',\n      temperature: 0.8,\n      max_response_output_tokens: 4096\n    };\n    this.sessionConfig = {};\n    this.transcriptionModels = [{\n      model: 'whisper-1'\n    }];\n    this.defaultServerVadConfig = {\n      type: 'server_vad',\n      threshold: 0.5,\n      // 0.0 to 1.0,\n      prefix_padding_ms: 300,\n      // How much audio to include in the audio stream before the speech starts.\n      silence_duration_ms: 200 // How long to wait to mark the speech as stopped.\n    };\n    this.realtime = new RealtimeAPI({\n      url,\n      apiKey,\n      dangerouslyAllowAPIKeyInBrowser,\n      debug\n    });\n    this.conversation = new RealtimeConversation();\n    this._resetConfig();\n    this._addAPIEventHandlers();\n  }\n\n  /**\n   * Resets sessionConfig and conversationConfig to default\n   * @private\n   * @returns {true}\n   */\n  _resetConfig() {\n    this.sessionCreated = false;\n    this.tools = {};\n    this.sessionConfig = JSON.parse(JSON.stringify(this.defaultSessionConfig));\n    this.inputAudioBuffer = new Int16Array(0);\n    return true;\n  }\n\n  /**\n   * Sets up event handlers for a fully-functional application control flow\n   * @private\n   * @returns {true}\n   */\n  _addAPIEventHandlers() {\n    // Event Logging handlers\n    this.realtime.on('client.*', event => {\n      const realtimeEvent = {\n        time: new Date().toISOString(),\n        source: 'client',\n        event: event\n      };\n      this.dispatch('realtime.event', realtimeEvent);\n    });\n    this.realtime.on('server.*', event => {\n      const realtimeEvent = {\n        time: new Date().toISOString(),\n        source: 'server',\n        event: event\n      };\n      this.dispatch('realtime.event', realtimeEvent);\n    });\n\n    // Handles session created event, can optionally wait for it\n    this.realtime.on('server.session.created', () => this.sessionCreated = true);\n\n    // Setup for application control flow\n    const handler = (event, ...args) => {\n      const {\n        item,\n        delta\n      } = this.conversation.processEvent(event, ...args);\n      return {\n        item,\n        delta\n      };\n    };\n    const handlerWithDispatch = (event, ...args) => {\n      const {\n        item,\n        delta\n      } = handler(event, ...args);\n      if (item) {\n        // FIXME: If statement is only here because item.input_audio_transcription.completed\n        //        can fire before `item.created`, resulting in empty item.\n        //        This happens in VAD mode with empty audio\n        this.dispatch('conversation.updated', {\n          item,\n          delta\n        });\n      }\n      return {\n        item,\n        delta\n      };\n    };\n    const callTool = async tool => {\n      try {\n        const jsonArguments = JSON.parse(tool.arguments);\n        const toolConfig = this.tools[tool.name];\n        if (!toolConfig) {\n          throw new Error(`Tool \"${tool.name}\" has not been added`);\n        }\n        const result = await toolConfig.handler(jsonArguments);\n        this.realtime.send('conversation.item.create', {\n          item: {\n            type: 'function_call_output',\n            call_id: tool.call_id,\n            output: JSON.stringify(result)\n          }\n        });\n      } catch (e) {\n        this.realtime.send('conversation.item.create', {\n          item: {\n            type: 'function_call_output',\n            call_id: tool.call_id,\n            output: JSON.stringify({\n              error: e.message\n            })\n          }\n        });\n      }\n      this.createResponse();\n    };\n\n    // Handlers to update internal conversation state\n    this.realtime.on('server.response.created', handler);\n    this.realtime.on('server.response.output_item.added', handler);\n    this.realtime.on('server.response.content_part.added', handler);\n    this.realtime.on('server.input_audio_buffer.speech_started', event => {\n      handler(event);\n      this.dispatch('conversation.interrupted');\n    });\n    this.realtime.on('server.input_audio_buffer.speech_stopped', event => handler(event, this.inputAudioBuffer));\n\n    // Handlers to update application state\n    this.realtime.on('server.conversation.item.created', event => {\n      const {\n        item\n      } = handlerWithDispatch(event);\n      this.dispatch('conversation.item.appended', {\n        item\n      });\n      if (item.status === 'completed') {\n        this.dispatch('conversation.item.completed', {\n          item\n        });\n      }\n    });\n    this.realtime.on('server.conversation.item.truncated', handlerWithDispatch);\n    this.realtime.on('server.conversation.item.deleted', handlerWithDispatch);\n    this.realtime.on('server.conversation.item.input_audio_transcription.completed', handlerWithDispatch);\n    this.realtime.on('server.response.audio_transcript.delta', handlerWithDispatch);\n    this.realtime.on('server.response.audio.delta', handlerWithDispatch);\n    this.realtime.on('server.response.text.delta', handlerWithDispatch);\n    this.realtime.on('server.response.function_call_arguments.delta', handlerWithDispatch);\n    this.realtime.on('server.response.output_item.done', async event => {\n      const {\n        item\n      } = handlerWithDispatch(event);\n      if (item.status === 'completed') {\n        this.dispatch('conversation.item.completed', {\n          item\n        });\n      }\n      if (item.formatted.tool) {\n        callTool(item.formatted.tool);\n      }\n    });\n    return true;\n  }\n\n  /**\n   * Tells us whether the realtime socket is connected and the session has started\n   * @returns {boolean}\n   */\n  isConnected() {\n    return this.realtime.isConnected();\n  }\n\n  /**\n   * Resets the client instance entirely: disconnects and clears active config\n   * @returns {true}\n   */\n  reset() {\n    this.disconnect();\n    this.clearEventHandlers();\n    this.realtime.clearEventHandlers();\n    this._resetConfig();\n    this._addAPIEventHandlers();\n    return true;\n  }\n\n  /**\n   * Connects to the Realtime WebSocket API\n   * Updates session config and conversation config\n   * @returns {Promise<true>}\n   */\n  async connect() {\n    if (this.isConnected()) {\n      throw new Error(`Already connected, use .disconnect() first`);\n    }\n    await this.realtime.connect();\n    this.updateSession();\n    return true;\n  }\n\n  /**\n   * Waits for a session.created event to be executed before proceeding\n   * @returns {Promise<true>}\n   */\n  async waitForSessionCreated() {\n    if (!this.isConnected()) {\n      throw new Error(`Not connected, use .connect() first`);\n    }\n    while (!this.sessionCreated) {\n      await new Promise(r => setTimeout(() => r(), 1));\n    }\n    return true;\n  }\n\n  /**\n   * Disconnects from the Realtime API and clears the conversation history\n   */\n  disconnect() {\n    this.sessionCreated = false;\n    this.conversation.clear();\n    this.realtime.isConnected() && this.realtime.disconnect();\n  }\n\n  /**\n   * Gets the active turn detection mode\n   * @returns {\"server_vad\"|null}\n   */\n  getTurnDetectionType() {\n    return this.sessionConfig.turn_detection?.type || null;\n  }\n\n  /**\n   * Add a tool and handler\n   * @param {ToolDefinitionType} definition\n   * @param {function} handler\n   * @returns {{definition: ToolDefinitionType, handler: function}}\n   */\n  addTool(definition, handler) {\n    if (!definition?.name) {\n      throw new Error(`Missing tool name in definition`);\n    }\n    const name = definition?.name;\n    if (this.tools[name]) {\n      throw new Error(`Tool \"${name}\" already added. Please use .removeTool(\"${name}\") before trying to add again.`);\n    }\n    if (typeof handler !== 'function') {\n      throw new Error(`Tool \"${name}\" handler must be a function`);\n    }\n    this.tools[name] = {\n      definition,\n      handler\n    };\n    this.updateSession();\n    return this.tools[name];\n  }\n\n  /**\n   * Removes a tool\n   * @param {string} name\n   * @returns {true}\n   */\n  removeTool(name) {\n    if (!this.tools[name]) {\n      throw new Error(`Tool \"${name}\" does not exist, can not be removed.`);\n    }\n    delete this.tools[name];\n    return true;\n  }\n\n  /**\n   * Deletes an item\n   * @param {string} id\n   * @returns {true}\n   */\n  deleteItem(id) {\n    this.realtime.send('conversation.item.delete', {\n      item_id: id\n    });\n    return true;\n  }\n\n  /**\n   * Updates session configuration\n   * If the client is not yet connected, will save details and instantiate upon connection\n   * @param {SessionResourceType} [sessionConfig]\n   */\n  updateSession({\n    modalities = void 0,\n    instructions = void 0,\n    voice = void 0,\n    input_audio_format = void 0,\n    output_audio_format = void 0,\n    input_audio_transcription = void 0,\n    turn_detection = void 0,\n    tools = void 0,\n    tool_choice = void 0,\n    temperature = void 0,\n    max_response_output_tokens = void 0\n  } = {}) {\n    modalities !== void 0 && (this.sessionConfig.modalities = modalities);\n    instructions !== void 0 && (this.sessionConfig.instructions = instructions);\n    voice !== void 0 && (this.sessionConfig.voice = voice);\n    input_audio_format !== void 0 && (this.sessionConfig.input_audio_format = input_audio_format);\n    output_audio_format !== void 0 && (this.sessionConfig.output_audio_format = output_audio_format);\n    input_audio_transcription !== void 0 && (this.sessionConfig.input_audio_transcription = input_audio_transcription);\n    turn_detection !== void 0 && (this.sessionConfig.turn_detection = turn_detection);\n    tools !== void 0 && (this.sessionConfig.tools = tools);\n    tool_choice !== void 0 && (this.sessionConfig.tool_choice = tool_choice);\n    temperature !== void 0 && (this.sessionConfig.temperature = temperature);\n    max_response_output_tokens !== void 0 && (this.sessionConfig.max_response_output_tokens = max_response_output_tokens);\n    // Load tools from tool definitions + already loaded tools\n    const useTools = [].concat((tools || []).map(toolDefinition => {\n      const definition = {\n        type: 'function',\n        ...toolDefinition\n      };\n      if (this.tools[definition?.name]) {\n        throw new Error(`Tool \"${definition?.name}\" has already been defined`);\n      }\n      return definition;\n    }), Object.keys(this.tools).map(key => {\n      return {\n        type: 'function',\n        ...this.tools[key].definition\n      };\n    }));\n    const session = {\n      ...this.sessionConfig\n    };\n    session.tools = useTools;\n    if (this.realtime.isConnected()) {\n      this.realtime.send('session.update', {\n        session\n      });\n    }\n    return true;\n  }\n\n  /**\n   * Sends user message content and generates a response\n   * @param {Array<InputTextContentType|InputAudioContentType>} content\n   * @returns {true}\n   */\n  sendUserMessageContent(content = []) {\n    if (content.length) {\n      for (const c of content) {\n        if (c.type === 'input_audio') {\n          if (c.audio instanceof ArrayBuffer || c.audio instanceof Int16Array) {\n            c.audio = RealtimeUtils.arrayBufferToBase64(c.audio);\n          }\n        }\n      }\n      this.realtime.send('conversation.item.create', {\n        item: {\n          type: 'message',\n          role: 'user',\n          content\n        }\n      });\n    }\n    this.createResponse();\n    return true;\n  }\n\n  /**\n   * Appends user audio to the existing audio buffer\n   * @param {Int16Array|ArrayBuffer} arrayBuffer\n   * @returns {true}\n   */\n  appendInputAudio(arrayBuffer) {\n    if (arrayBuffer.byteLength > 0) {\n      this.realtime.send('input_audio_buffer.append', {\n        audio: RealtimeUtils.arrayBufferToBase64(arrayBuffer)\n      });\n      this.inputAudioBuffer = RealtimeUtils.mergeInt16Arrays(this.inputAudioBuffer, arrayBuffer);\n    }\n    return true;\n  }\n\n  /**\n   * Forces a model response generation\n   * @returns {true}\n   */\n  createResponse() {\n    if (this.getTurnDetectionType() === null && this.inputAudioBuffer.byteLength > 0) {\n      this.realtime.send('input_audio_buffer.commit');\n      this.conversation.queueInputAudio(this.inputAudioBuffer);\n      this.inputAudioBuffer = new Int16Array(0);\n    }\n    this.realtime.send('response.create');\n    return true;\n  }\n\n  /**\n   * Cancels the ongoing server generation and truncates ongoing generation, if applicable\n   * If no id provided, will simply call `cancel_generation` command\n   * @param {string} id The id of the message to cancel\n   * @param {number} [sampleCount] The number of samples to truncate past for the ongoing generation\n   * @returns {{item: (AssistantItemType | null)}}\n   */\n  cancelResponse(id, sampleCount = 0) {\n    if (!id) {\n      this.realtime.send('response.cancel');\n      return {\n        item: null\n      };\n    } else if (id) {\n      const item = this.conversation.getItem(id);\n      if (!item) {\n        throw new Error(`Could not find item \"${id}\"`);\n      }\n      if (item.type !== 'message') {\n        throw new Error(`Can only cancelResponse messages with type \"message\"`);\n      } else if (item.role !== 'assistant') {\n        throw new Error(`Can only cancelResponse messages with role \"assistant\"`);\n      }\n      this.realtime.send('response.cancel');\n      const audioIndex = item.content.findIndex(c => c.type === 'audio');\n      if (audioIndex === -1) {\n        throw new Error(`Could not find audio on item to cancel`);\n      }\n      this.realtime.send('conversation.item.truncate', {\n        item_id: id,\n        content_index: audioIndex,\n        audio_end_ms: Math.floor(sampleCount / this.conversation.defaultFrequency * 1000)\n      });\n      return {\n        item\n      };\n    }\n  }\n\n  /**\n   * Utility for waiting for the next `conversation.item.appended` event to be triggered by the server\n   * @returns {Promise<{item: ItemType}>}\n   */\n  async waitForNextItem() {\n    const event = await this.waitForNext('conversation.item.appended');\n    const {\n      item\n    } = event;\n    return {\n      item\n    };\n  }\n\n  /**\n   * Utility for waiting for the next `conversation.item.completed` event to be triggered by the server\n   * @returns {Promise<{item: ItemType}>}\n   */\n  async waitForNextCompletedItem() {\n    const event = await this.waitForNext('conversation.item.completed');\n    const {\n      item\n    } = event;\n    return {\n      item\n    };\n  }\n}","map":{"version":3,"names":["RealtimeEventHandler","RealtimeAPI","RealtimeConversation","RealtimeUtils","RealtimeClient","constructor","url","apiKey","dangerouslyAllowAPIKeyInBrowser","debug","defaultSessionConfig","modalities","instructions","voice","input_audio_format","output_audio_format","input_audio_transcription","turn_detection","tools","tool_choice","temperature","max_response_output_tokens","sessionConfig","transcriptionModels","model","defaultServerVadConfig","type","threshold","prefix_padding_ms","silence_duration_ms","realtime","conversation","_resetConfig","_addAPIEventHandlers","sessionCreated","JSON","parse","stringify","inputAudioBuffer","Int16Array","on","event","realtimeEvent","time","Date","toISOString","source","dispatch","handler","args","item","delta","processEvent","handlerWithDispatch","callTool","tool","jsonArguments","arguments","toolConfig","name","Error","result","send","call_id","output","e","error","message","createResponse","status","formatted","isConnected","reset","disconnect","clearEventHandlers","connect","updateSession","waitForSessionCreated","Promise","r","setTimeout","clear","getTurnDetectionType","addTool","definition","removeTool","deleteItem","id","item_id","useTools","concat","map","toolDefinition","Object","keys","key","session","sendUserMessageContent","content","length","c","audio","ArrayBuffer","arrayBufferToBase64","role","appendInputAudio","arrayBuffer","byteLength","mergeInt16Arrays","queueInputAudio","cancelResponse","sampleCount","getItem","audioIndex","findIndex","content_index","audio_end_ms","Math","floor","defaultFrequency","waitForNextItem","waitForNext","waitForNextCompletedItem"],"sources":["/Users/michaelmccarthy/Desktop/work_local/nxt_humans/projects/nxt-hackathon-front-end-app/node_modules/@openai/realtime-api-beta/lib/client.js"],"sourcesContent":["import { RealtimeEventHandler } from './event_handler.js';\nimport { RealtimeAPI } from './api.js';\nimport { RealtimeConversation } from './conversation.js';\nimport { RealtimeUtils } from './utils.js';\n\n/**\n * Valid audio formats\n * @typedef {\"pcm16\"|\"g711-ulaw\"|\"g711-alaw\"} AudioFormatType\n */\n\n/**\n * @typedef {Object} AudioTranscriptionType\n * @property {boolean} [enabled]\n * @property {\"whisper-1\"} model\n */\n\n/**\n * @typedef {Object} TurnDetectionServerVadType\n * @property {\"server_vad\"} type\n * @property {number} [threshold]\n * @property {number} [prefix_padding_ms]\n * @property {number} [silence_duration_ms]\n */\n\n/**\n * Tool definitions\n * @typedef {Object} ToolDefinitionType\n * @property {\"function\"} [type]\n * @property {string} name\n * @property {string} description\n * @property {{[key: string]: any}} parameters\n */\n\n/**\n * @typedef {Object} SessionResourceType\n * @property {string} [model]\n * @property {string[]} [modalities]\n * @property {string} [instructions]\n * @property {\"alloy\"|\"shimmer\"|\"echo\"} [voice]\n * @property {AudioFormatType} [input_audio_format]\n * @property {AudioFormatType} [output_audio_format]\n * @property {AudioTranscriptionType|null} [input_audio_transcription]\n * @property {TurnDetectionServerVadType|null} [turn_detection]\n * @property {ToolDefinitionType[]} [tools]\n * @property {\"auto\"|\"none\"|\"required\"|{type:\"function\",name:string}} [tool_choice]\n * @property {number} [temperature]\n * @property {number|\"inf\"} [max_response_output_tokens]\n */\n\n/**\n * @typedef {\"in_progress\"|\"completed\"|\"incomplete\"} ItemStatusType\n */\n\n/**\n * @typedef {Object} InputTextContentType\n * @property {\"input_text\"} type\n * @property {string} text\n */\n\n/**\n * @typedef {Object} InputAudioContentType\n * @property {\"input_audio\"} type\n * @property {string} [audio] base64-encoded audio data\n * @property {string|null} [transcript]\n */\n\n/**\n * @typedef {Object} TextContentType\n * @property {\"text\"} type\n * @property {string} text\n */\n\n/**\n * @typedef {Object} AudioContentType\n * @property {\"audio\"} type\n * @property {string} [audio] base64-encoded audio data\n * @property {string|null} [transcript]\n */\n\n/**\n * @typedef {Object} SystemItemType\n * @property {string|null} [previous_item_id]\n * @property {\"message\"} type\n * @property {ItemStatusType} status\n * @property {\"system\"} role\n * @property {Array<InputTextContentType>} content\n */\n\n/**\n * @typedef {Object} UserItemType\n * @property {string|null} [previous_item_id]\n * @property {\"message\"} type\n * @property {ItemStatusType} status\n * @property {\"system\"} role\n * @property {Array<InputTextContentType|InputAudioContentType>} content\n */\n\n/**\n * @typedef {Object} AssistantItemType\n * @property {string|null} [previous_item_id]\n * @property {\"message\"} type\n * @property {ItemStatusType} status\n * @property {\"assistant\"} role\n * @property {Array<TextContentType|AudioContentType>} content\n */\n\n/**\n * @typedef {Object} FunctionCallItemType\n * @property {string|null} [previous_item_id]\n * @property {\"function_call\"} type\n * @property {ItemStatusType} status\n * @property {string} call_id\n * @property {string} name\n * @property {string} arguments\n */\n\n/**\n * @typedef {Object} FunctionCallOutputItemType\n * @property {string|null} [previous_item_id]\n * @property {\"function_call_output\"} type\n * @property {string} call_id\n * @property {string} output\n */\n\n/**\n * @typedef {Object} FormattedToolType\n * @property {\"function\"} type\n * @property {string} name\n * @property {string} call_id\n * @property {string} arguments\n */\n\n/**\n * @typedef {Object} FormattedPropertyType\n * @property {Int16Array} [audio]\n * @property {string} [text]\n * @property {string} [transcript]\n * @property {FormattedToolType} [tool]\n * @property {string} [output]\n * @property {any} [file]\n */\n\n/**\n * @typedef {Object} FormattedItemType\n * @property {string} id\n * @property {string} object\n * @property {\"user\"|\"assistant\"|\"system\"} [role]\n * @property {FormattedPropertyType} formatted\n */\n\n/**\n * @typedef {SystemItemType|UserItemType|AssistantItemType|FunctionCallItemType|FunctionCallOutputItemType} BaseItemType\n */\n\n/**\n * @typedef {FormattedItemType & BaseItemType} ItemType\n */\n\n/**\n * @typedef {Object} IncompleteResponseStatusType\n * @property {\"incomplete\"} type\n * @property {\"interruption\"|\"max_output_tokens\"|\"content_filter\"} reason\n */\n\n/**\n * @typedef {Object} FailedResponseStatusType\n * @property {\"failed\"} type\n * @property {{code: string, message: string}|null} error\n */\n\n/**\n * @typedef {Object} UsageType\n * @property {number} total_tokens\n * @property {number} input_tokens\n * @property {number} output_tokens\n */\n\n/**\n * @typedef {Object} ResponseResourceType\n * @property {\"in_progress\"|\"completed\"|\"incomplete\"|\"cancelled\"|\"failed\"} status\n * @property {IncompleteResponseStatusType|FailedResponseStatusType|null} status_details\n * @property {ItemType[]} output\n * @property {UsageType|null} usage\n */\n\n/**\n * RealtimeClient Class\n * @class\n */\nexport class RealtimeClient extends RealtimeEventHandler {\n  /**\n   * Create a new RealtimeClient instance\n   * @param {{url?: string, apiKey?: string, dangerouslyAllowAPIKeyInBrowser?: boolean, debug?: boolean}} [settings]\n   */\n  constructor({ url, apiKey, dangerouslyAllowAPIKeyInBrowser, debug } = {}) {\n    super();\n    this.defaultSessionConfig = {\n      modalities: ['text', 'audio'],\n      instructions: '',\n      voice: 'alloy',\n      input_audio_format: 'pcm16',\n      output_audio_format: 'pcm16',\n      input_audio_transcription: null,\n      turn_detection: null,\n      tools: [],\n      tool_choice: 'auto',\n      temperature: 0.8,\n      max_response_output_tokens: 4096,\n    };\n    this.sessionConfig = {};\n    this.transcriptionModels = [\n      {\n        model: 'whisper-1',\n      },\n    ];\n    this.defaultServerVadConfig = {\n      type: 'server_vad',\n      threshold: 0.5, // 0.0 to 1.0,\n      prefix_padding_ms: 300, // How much audio to include in the audio stream before the speech starts.\n      silence_duration_ms: 200, // How long to wait to mark the speech as stopped.\n    };\n    this.realtime = new RealtimeAPI({\n      url,\n      apiKey,\n      dangerouslyAllowAPIKeyInBrowser,\n      debug,\n    });\n    this.conversation = new RealtimeConversation();\n    this._resetConfig();\n    this._addAPIEventHandlers();\n  }\n\n  /**\n   * Resets sessionConfig and conversationConfig to default\n   * @private\n   * @returns {true}\n   */\n  _resetConfig() {\n    this.sessionCreated = false;\n    this.tools = {};\n    this.sessionConfig = JSON.parse(JSON.stringify(this.defaultSessionConfig));\n    this.inputAudioBuffer = new Int16Array(0);\n    return true;\n  }\n\n  /**\n   * Sets up event handlers for a fully-functional application control flow\n   * @private\n   * @returns {true}\n   */\n  _addAPIEventHandlers() {\n    // Event Logging handlers\n    this.realtime.on('client.*', (event) => {\n      const realtimeEvent = {\n        time: new Date().toISOString(),\n        source: 'client',\n        event: event,\n      };\n      this.dispatch('realtime.event', realtimeEvent);\n    });\n    this.realtime.on('server.*', (event) => {\n      const realtimeEvent = {\n        time: new Date().toISOString(),\n        source: 'server',\n        event: event,\n      };\n      this.dispatch('realtime.event', realtimeEvent);\n    });\n\n    // Handles session created event, can optionally wait for it\n    this.realtime.on(\n      'server.session.created',\n      () => (this.sessionCreated = true),\n    );\n\n    // Setup for application control flow\n    const handler = (event, ...args) => {\n      const { item, delta } = this.conversation.processEvent(event, ...args);\n      return { item, delta };\n    };\n    const handlerWithDispatch = (event, ...args) => {\n      const { item, delta } = handler(event, ...args);\n      if (item) {\n        // FIXME: If statement is only here because item.input_audio_transcription.completed\n        //        can fire before `item.created`, resulting in empty item.\n        //        This happens in VAD mode with empty audio\n        this.dispatch('conversation.updated', { item, delta });\n      }\n      return { item, delta };\n    };\n    const callTool = async (tool) => {\n      try {\n        const jsonArguments = JSON.parse(tool.arguments);\n        const toolConfig = this.tools[tool.name];\n        if (!toolConfig) {\n          throw new Error(`Tool \"${tool.name}\" has not been added`);\n        }\n        const result = await toolConfig.handler(jsonArguments);\n        this.realtime.send('conversation.item.create', {\n          item: {\n            type: 'function_call_output',\n            call_id: tool.call_id,\n            output: JSON.stringify(result),\n          },\n        });\n      } catch (e) {\n        this.realtime.send('conversation.item.create', {\n          item: {\n            type: 'function_call_output',\n            call_id: tool.call_id,\n            output: JSON.stringify({ error: e.message }),\n          },\n        });\n      }\n      this.createResponse();\n    };\n\n    // Handlers to update internal conversation state\n    this.realtime.on('server.response.created', handler);\n    this.realtime.on('server.response.output_item.added', handler);\n    this.realtime.on('server.response.content_part.added', handler);\n    this.realtime.on('server.input_audio_buffer.speech_started', (event) => {\n      handler(event);\n      this.dispatch('conversation.interrupted');\n    });\n    this.realtime.on('server.input_audio_buffer.speech_stopped', (event) =>\n      handler(event, this.inputAudioBuffer),\n    );\n\n    // Handlers to update application state\n    this.realtime.on('server.conversation.item.created', (event) => {\n      const { item } = handlerWithDispatch(event);\n      this.dispatch('conversation.item.appended', { item });\n      if (item.status === 'completed') {\n        this.dispatch('conversation.item.completed', { item });\n      }\n    });\n    this.realtime.on('server.conversation.item.truncated', handlerWithDispatch);\n    this.realtime.on('server.conversation.item.deleted', handlerWithDispatch);\n    this.realtime.on(\n      'server.conversation.item.input_audio_transcription.completed',\n      handlerWithDispatch,\n    );\n    this.realtime.on(\n      'server.response.audio_transcript.delta',\n      handlerWithDispatch,\n    );\n    this.realtime.on('server.response.audio.delta', handlerWithDispatch);\n    this.realtime.on('server.response.text.delta', handlerWithDispatch);\n    this.realtime.on(\n      'server.response.function_call_arguments.delta',\n      handlerWithDispatch,\n    );\n    this.realtime.on('server.response.output_item.done', async (event) => {\n      const { item } = handlerWithDispatch(event);\n      if (item.status === 'completed') {\n        this.dispatch('conversation.item.completed', { item });\n      }\n      if (item.formatted.tool) {\n        callTool(item.formatted.tool);\n      }\n    });\n\n    return true;\n  }\n\n  /**\n   * Tells us whether the realtime socket is connected and the session has started\n   * @returns {boolean}\n   */\n  isConnected() {\n    return this.realtime.isConnected();\n  }\n\n  /**\n   * Resets the client instance entirely: disconnects and clears active config\n   * @returns {true}\n   */\n  reset() {\n    this.disconnect();\n    this.clearEventHandlers();\n    this.realtime.clearEventHandlers();\n    this._resetConfig();\n    this._addAPIEventHandlers();\n    return true;\n  }\n\n  /**\n   * Connects to the Realtime WebSocket API\n   * Updates session config and conversation config\n   * @returns {Promise<true>}\n   */\n  async connect() {\n    if (this.isConnected()) {\n      throw new Error(`Already connected, use .disconnect() first`);\n    }\n    await this.realtime.connect();\n    this.updateSession();\n    return true;\n  }\n\n  /**\n   * Waits for a session.created event to be executed before proceeding\n   * @returns {Promise<true>}\n   */\n  async waitForSessionCreated() {\n    if (!this.isConnected()) {\n      throw new Error(`Not connected, use .connect() first`);\n    }\n    while (!this.sessionCreated) {\n      await new Promise((r) => setTimeout(() => r(), 1));\n    }\n    return true;\n  }\n\n  /**\n   * Disconnects from the Realtime API and clears the conversation history\n   */\n  disconnect() {\n    this.sessionCreated = false;\n    this.conversation.clear();\n    this.realtime.isConnected() && this.realtime.disconnect();\n  }\n\n  /**\n   * Gets the active turn detection mode\n   * @returns {\"server_vad\"|null}\n   */\n  getTurnDetectionType() {\n    return this.sessionConfig.turn_detection?.type || null;\n  }\n\n  /**\n   * Add a tool and handler\n   * @param {ToolDefinitionType} definition\n   * @param {function} handler\n   * @returns {{definition: ToolDefinitionType, handler: function}}\n   */\n  addTool(definition, handler) {\n    if (!definition?.name) {\n      throw new Error(`Missing tool name in definition`);\n    }\n    const name = definition?.name;\n    if (this.tools[name]) {\n      throw new Error(\n        `Tool \"${name}\" already added. Please use .removeTool(\"${name}\") before trying to add again.`,\n      );\n    }\n    if (typeof handler !== 'function') {\n      throw new Error(`Tool \"${name}\" handler must be a function`);\n    }\n    this.tools[name] = { definition, handler };\n    this.updateSession();\n    return this.tools[name];\n  }\n\n  /**\n   * Removes a tool\n   * @param {string} name\n   * @returns {true}\n   */\n  removeTool(name) {\n    if (!this.tools[name]) {\n      throw new Error(`Tool \"${name}\" does not exist, can not be removed.`);\n    }\n    delete this.tools[name];\n    return true;\n  }\n\n  /**\n   * Deletes an item\n   * @param {string} id\n   * @returns {true}\n   */\n  deleteItem(id) {\n    this.realtime.send('conversation.item.delete', { item_id: id });\n    return true;\n  }\n\n  /**\n   * Updates session configuration\n   * If the client is not yet connected, will save details and instantiate upon connection\n   * @param {SessionResourceType} [sessionConfig]\n   */\n  updateSession({\n    modalities = void 0,\n    instructions = void 0,\n    voice = void 0,\n    input_audio_format = void 0,\n    output_audio_format = void 0,\n    input_audio_transcription = void 0,\n    turn_detection = void 0,\n    tools = void 0,\n    tool_choice = void 0,\n    temperature = void 0,\n    max_response_output_tokens = void 0,\n  } = {}) {\n    modalities !== void 0 && (this.sessionConfig.modalities = modalities);\n    instructions !== void 0 && (this.sessionConfig.instructions = instructions);\n    voice !== void 0 && (this.sessionConfig.voice = voice);\n    input_audio_format !== void 0 &&\n      (this.sessionConfig.input_audio_format = input_audio_format);\n    output_audio_format !== void 0 &&\n      (this.sessionConfig.output_audio_format = output_audio_format);\n    input_audio_transcription !== void 0 &&\n      (this.sessionConfig.input_audio_transcription =\n        input_audio_transcription);\n    turn_detection !== void 0 &&\n      (this.sessionConfig.turn_detection = turn_detection);\n    tools !== void 0 && (this.sessionConfig.tools = tools);\n    tool_choice !== void 0 && (this.sessionConfig.tool_choice = tool_choice);\n    temperature !== void 0 && (this.sessionConfig.temperature = temperature);\n    max_response_output_tokens !== void 0 &&\n      (this.sessionConfig.max_response_output_tokens =\n        max_response_output_tokens);\n    // Load tools from tool definitions + already loaded tools\n    const useTools = [].concat(\n      (tools || []).map((toolDefinition) => {\n        const definition = {\n          type: 'function',\n          ...toolDefinition,\n        };\n        if (this.tools[definition?.name]) {\n          throw new Error(\n            `Tool \"${definition?.name}\" has already been defined`,\n          );\n        }\n        return definition;\n      }),\n      Object.keys(this.tools).map((key) => {\n        return {\n          type: 'function',\n          ...this.tools[key].definition,\n        };\n      }),\n    );\n    const session = { ...this.sessionConfig };\n    session.tools = useTools;\n    if (this.realtime.isConnected()) {\n      this.realtime.send('session.update', { session });\n    }\n    return true;\n  }\n\n  /**\n   * Sends user message content and generates a response\n   * @param {Array<InputTextContentType|InputAudioContentType>} content\n   * @returns {true}\n   */\n  sendUserMessageContent(content = []) {\n    if (content.length) {\n      for (const c of content) {\n        if (c.type === 'input_audio') {\n          if (c.audio instanceof ArrayBuffer || c.audio instanceof Int16Array) {\n            c.audio = RealtimeUtils.arrayBufferToBase64(c.audio);\n          }\n        }\n      }\n      this.realtime.send('conversation.item.create', {\n        item: {\n          type: 'message',\n          role: 'user',\n          content,\n        },\n      });\n    }\n    this.createResponse();\n    return true;\n  }\n\n  /**\n   * Appends user audio to the existing audio buffer\n   * @param {Int16Array|ArrayBuffer} arrayBuffer\n   * @returns {true}\n   */\n  appendInputAudio(arrayBuffer) {\n    if (arrayBuffer.byteLength > 0) {\n      this.realtime.send('input_audio_buffer.append', {\n        audio: RealtimeUtils.arrayBufferToBase64(arrayBuffer),\n      });\n      this.inputAudioBuffer = RealtimeUtils.mergeInt16Arrays(\n        this.inputAudioBuffer,\n        arrayBuffer,\n      );\n    }\n    return true;\n  }\n\n  /**\n   * Forces a model response generation\n   * @returns {true}\n   */\n  createResponse() {\n    if (\n      this.getTurnDetectionType() === null &&\n      this.inputAudioBuffer.byteLength > 0\n    ) {\n      this.realtime.send('input_audio_buffer.commit');\n      this.conversation.queueInputAudio(this.inputAudioBuffer);\n      this.inputAudioBuffer = new Int16Array(0);\n    }\n    this.realtime.send('response.create');\n    return true;\n  }\n\n  /**\n   * Cancels the ongoing server generation and truncates ongoing generation, if applicable\n   * If no id provided, will simply call `cancel_generation` command\n   * @param {string} id The id of the message to cancel\n   * @param {number} [sampleCount] The number of samples to truncate past for the ongoing generation\n   * @returns {{item: (AssistantItemType | null)}}\n   */\n  cancelResponse(id, sampleCount = 0) {\n    if (!id) {\n      this.realtime.send('response.cancel');\n      return { item: null };\n    } else if (id) {\n      const item = this.conversation.getItem(id);\n      if (!item) {\n        throw new Error(`Could not find item \"${id}\"`);\n      }\n      if (item.type !== 'message') {\n        throw new Error(`Can only cancelResponse messages with type \"message\"`);\n      } else if (item.role !== 'assistant') {\n        throw new Error(\n          `Can only cancelResponse messages with role \"assistant\"`,\n        );\n      }\n      this.realtime.send('response.cancel');\n      const audioIndex = item.content.findIndex((c) => c.type === 'audio');\n      if (audioIndex === -1) {\n        throw new Error(`Could not find audio on item to cancel`);\n      }\n      this.realtime.send('conversation.item.truncate', {\n        item_id: id,\n        content_index: audioIndex,\n        audio_end_ms: Math.floor(\n          (sampleCount / this.conversation.defaultFrequency) * 1000,\n        ),\n      });\n      return { item };\n    }\n  }\n\n  /**\n   * Utility for waiting for the next `conversation.item.appended` event to be triggered by the server\n   * @returns {Promise<{item: ItemType}>}\n   */\n  async waitForNextItem() {\n    const event = await this.waitForNext('conversation.item.appended');\n    const { item } = event;\n    return { item };\n  }\n\n  /**\n   * Utility for waiting for the next `conversation.item.completed` event to be triggered by the server\n   * @returns {Promise<{item: ItemType}>}\n   */\n  async waitForNextCompletedItem() {\n    const event = await this.waitForNext('conversation.item.completed');\n    const { item } = event;\n    return { item };\n  }\n}\n"],"mappings":"AAAA,SAASA,oBAAoB,QAAQ,oBAAoB;AACzD,SAASC,WAAW,QAAQ,UAAU;AACtC,SAASC,oBAAoB,QAAQ,mBAAmB;AACxD,SAASC,aAAa,QAAQ,YAAY;;AAE1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,MAAMC,cAAc,SAASJ,oBAAoB,CAAC;EACvD;AACF;AACA;AACA;EACEK,WAAWA,CAAC;IAAEC,GAAG;IAAEC,MAAM;IAAEC,+BAA+B;IAAEC;EAAM,CAAC,GAAG,CAAC,CAAC,EAAE;IACxE,KAAK,CAAC,CAAC;IACP,IAAI,CAACC,oBAAoB,GAAG;MAC1BC,UAAU,EAAE,CAAC,MAAM,EAAE,OAAO,CAAC;MAC7BC,YAAY,EAAE,EAA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}