{"ast":null,"code":"import { RealtimeUtils } from './utils.js';\n\n/**\n * Contains text and audio information about a item\n * Can also be used as a delta\n * @typedef {Object} ItemContentDeltaType\n * @property {string} [text]\n * @property {Int16Array} [audio]\n * @property {string} [arguments]\n * @property {string} [transcript]\n */\n\n/**\n * RealtimeConversation holds conversation history\n * and performs event validation for RealtimeAPI\n * @class\n */\nexport class RealtimeConversation {\n  defaultFrequency = 24_000; // 24,000 Hz\n\n  EventProcessors = {\n    'conversation.item.created': event => {\n      const {\n        item\n      } = event;\n      // deep copy values\n      const newItem = JSON.parse(JSON.stringify(item));\n      if (!this.itemLookup[newItem.id]) {\n        this.itemLookup[newItem.id] = newItem;\n        this.items.push(newItem);\n      }\n      newItem.formatted = {};\n      newItem.formatted.audio = new Int16Array(0);\n      newItem.formatted.text = '';\n      newItem.formatted.transcript = '';\n      // If we have a speech item, can populate audio\n      if (this.queuedSpeechItems[newItem.id]) {\n        newItem.formatted.audio = this.queuedSpeechItems[newItem.id].audio;\n        delete this.queuedSpeechItems[newItem.id]; // free up some memory\n      }\n      // Populate formatted text if it comes out on creation\n      if (newItem.content) {\n        const textContent = newItem.content.filter(c => ['text', 'input_text'].includes(c.type));\n        for (const content of textContent) {\n          newItem.formatted.text += content.text;\n        }\n      }\n      // If we have a transcript item, can pre-populate transcript\n      if (this.queuedTranscriptItems[newItem.id]) {\n        newItem.formatted.transcript = this.queuedTranscriptItems.transcript;\n        delete this.queuedTranscriptItems[newItem.id];\n      }\n      if (newItem.type === 'message') {\n        if (newItem.role === 'user') {\n          newItem.status = 'completed';\n          if (this.queuedInputAudio) {\n            newItem.formatted.audio = this.queuedInputAudio;\n            this.queuedInputAudio = null;\n          }\n        } else {\n          newItem.status = 'in_progress';\n        }\n      } else if (newItem.type === 'function_call') {\n        newItem.formatted.tool = {\n          type: 'function',\n          name: newItem.name,\n          call_id: newItem.call_id,\n          arguments: ''\n        };\n        newItem.status = 'in_progress';\n      } else if (newItem.type === 'function_call_output') {\n        newItem.status = 'completed';\n        newItem.formatted.output = newItem.output;\n      }\n      return {\n        item: newItem,\n        delta: null\n      };\n    },\n    'conversation.item.truncated': event => {\n      const {\n        item_id,\n        audio_end_ms\n      } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(`item.truncated: Item \"${item_id}\" not found`);\n      }\n      const endIndex = Math.floor(audio_end_ms * this.defaultFrequency / 1000);\n      item.formatted.transcript = '';\n      item.formatted.audio = item.formatted.audio.slice(0, endIndex);\n      return {\n        item,\n        delta: null\n      };\n    },\n    'conversation.item.deleted': event => {\n      const {\n        item_id\n      } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(`item.deleted: Item \"${item_id}\" not found`);\n      }\n      delete this.itemLookup[item.id];\n      const index = this.items.indexOf(item);\n      if (index > -1) {\n        this.items.splice(index, 1);\n      }\n      return {\n        item,\n        delta: null\n      };\n    },\n    'conversation.item.input_audio_transcription.completed': event => {\n      const {\n        item_id,\n        content_index,\n        transcript\n      } = event;\n      const item = this.itemLookup[item_id];\n      // We use a single space to represent an empty transcript for .formatted values\n      // Otherwise it looks like no transcript provided\n      const formattedTranscript = transcript || ' ';\n      if (!item) {\n        // We can receive transcripts in VAD mode before item.created\n        // This happens specifically when audio is empty\n        this.queuedTranscriptItems[item_id] = {\n          transcript: formattedTranscript\n        };\n        return {\n          item: null,\n          delta: null\n        };\n      } else {\n        item.content[content_index].transcript = transcript;\n        item.formatted.transcript = formattedTranscript;\n        return {\n          item,\n          delta: {\n            transcript\n          }\n        };\n      }\n    },\n    'input_audio_buffer.speech_started': event => {\n      const {\n        item_id,\n        audio_start_ms\n      } = event;\n      this.queuedSpeechItems[item_id] = {\n        audio_start_ms\n      };\n      return {\n        item: null,\n        delta: null\n      };\n    },\n    'input_audio_buffer.speech_stopped': (event, inputAudioBuffer) => {\n      const {\n        item_id,\n        audio_end_ms\n      } = event;\n      const speech = this.queuedSpeechItems[item_id];\n      speech.audio_end_ms = audio_end_ms;\n      if (inputAudioBuffer) {\n        const startIndex = Math.floor(speech.audio_start_ms * this.defaultFrequency / 1000);\n        const endIndex = Math.floor(speech.audio_end_ms * this.defaultFrequency / 1000);\n        speech.audio = inputAudioBuffer.slice(startIndex, endIndex);\n      }\n      return {\n        item: null,\n        delta: null\n      };\n    },\n    'response.created': event => {\n      const {\n        response\n      } = event;\n      if (!this.responseLookup[response.id]) {\n        this.responseLookup[response.id] = response;\n        this.responses.push(response);\n      }\n      return {\n        item: null,\n        delta: null\n      };\n    },\n    'response.output_item.added': event => {\n      const {\n        response_id,\n        item\n      } = event;\n      const response = this.responseLookup[response_id];\n      if (!response) {\n        throw new Error(`response.output_item.added: Response \"${response_id}\" not found`);\n      }\n      response.output.push(item.id);\n      return {\n        item: null,\n        delta: null\n      };\n    },\n    'response.output_item.done': event => {\n      const {\n        item\n      } = event;\n      if (!item) {\n        throw new Error(`response.output_item.done: Missing \"item\"`);\n      }\n      const foundItem = this.itemLookup[item.id];\n      if (!foundItem) {\n        throw new Error(`response.output_item.done: Item \"${item.id}\" not found`);\n      }\n      foundItem.status = item.status;\n      return {\n        item: foundItem,\n        delta: null\n      };\n    },\n    'response.content_part.added': event => {\n      const {\n        item_id,\n        part\n      } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(`response.content_part.added: Item \"${item_id}\" not found`);\n      }\n      item.content.push(part);\n      return {\n        item,\n        delta: null\n      };\n    },\n    'response.audio_transcript.delta': event => {\n      const {\n        item_id,\n        content_index,\n        delta\n      } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(`response.audio_transcript.delta: Item \"${item_id}\" not found`);\n      }\n      item.content[content_index].transcript += delta;\n      item.formatted.transcript += delta;\n      return {\n        item,\n        delta: {\n          transcript: delta\n        }\n      };\n    },\n    'response.audio.delta': event => {\n      const {\n        item_id,\n        content_index,\n        delta\n      } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(`response.audio.delta: Item \"${item_id}\" not found`);\n      }\n      // This never gets renderered, we care about the file data instead\n      // item.content[content_index].audio += delta;\n      const arrayBuffer = RealtimeUtils.base64ToArrayBuffer(delta);\n      const appendValues = new Int16Array(arrayBuffer);\n      item.formatted.audio = RealtimeUtils.mergeInt16Arrays(item.formatted.audio, appendValues);\n      return {\n        item,\n        delta: {\n          audio: appendValues\n        }\n      };\n    },\n    'response.text.delta': event => {\n      const {\n        item_id,\n        content_index,\n        delta\n      } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(`response.text.delta: Item \"${item_id}\" not found`);\n      }\n      item.content[content_index].text += delta;\n      item.formatted.text += delta;\n      return {\n        item,\n        delta: {\n          text: delta\n        }\n      };\n    },\n    'response.function_call_arguments.delta': event => {\n      const {\n        item_id,\n        delta\n      } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(`response.function_call_arguments.delta: Item \"${item_id}\" not found`);\n      }\n      item.arguments += delta;\n      item.formatted.tool.arguments += delta;\n      return {\n        item,\n        delta: {\n          arguments: delta\n        }\n      };\n    }\n  };\n\n  /**\n   * Create a new RealtimeConversation instance\n   * @returns {RealtimeConversation}\n   */\n  constructor() {\n    this.clear();\n  }\n\n  /**\n   * Clears the conversation history and resets to default\n   * @returns {true}\n   */\n  clear() {\n    this.itemLookup = {};\n    this.items = [];\n    this.responseLookup = {};\n    this.responses = [];\n    this.queuedSpeechItems = {};\n    this.queuedTranscriptItems = {};\n    this.queuedInputAudio = null;\n    return true;\n  }\n\n  /**\n   * Queue input audio for manual speech event\n   * @param {Int16Array} inputAudio\n   * @returns {Int16Array}\n   */\n  queueInputAudio(inputAudio) {\n    this.queuedInputAudio = inputAudio;\n    return inputAudio;\n  }\n\n  /**\n   * Process an event from the WebSocket server and compose items\n   * @param {Object} event\n   * @param  {...any} args\n   * @returns {item: import('./client.js').ItemType | null, delta: ItemContentDeltaType | null}\n   */\n  processEvent(event, ...args) {\n    if (!event.event_id) {\n      console.error(event);\n      throw new Error(`Missing \"event_id\" on event`);\n    }\n    if (!event.type) {\n      console.error(event);\n      throw new Error(`Missing \"type\" on event`);\n    }\n    const eventProcessor = this.EventProcessors[event.type];\n    if (!eventProcessor) {\n      throw new Error(`Missing conversation event processor for \"${event.type}\"`);\n    }\n    return eventProcessor.call(this, event, ...args);\n  }\n\n  /**\n   * Retrieves a item by id\n   * @param {string} id\n   * @returns {import('./client.js').ItemType}\n   */\n  getItem(id) {\n    return this.itemLookup[id] || null;\n  }\n\n  /**\n   * Retrieves all items in the conversation\n   * @returns {import('./client.js').ItemType[]}\n   */\n  getItems() {\n    return this.items.slice();\n  }\n}","map":{"version":3,"names":["RealtimeUtils","RealtimeConversation","defaultFrequency","EventProcessors","event","item","newItem","JSON","parse","stringify","itemLookup","id","items","push","formatted","audio","Int16Array","text","transcript","queuedSpeechItems","content","textContent","filter","c","includes","type","queuedTranscriptItems","role","status","queuedInputAudio","tool","name","call_id","arguments","output","delta","item_id","audio_end_ms","Error","endIndex","Math","floor","slice","index","indexOf","splice","content_index","formattedTranscript","audio_start_ms","input_audio_buffer.speech_stopped","inputAudioBuffer","speech","startIndex","response","responseLookup","responses","response_id","foundItem","part","arrayBuffer","base64ToArrayBuffer","appendValues","mergeInt16Arrays","constructor","clear","queueInputAudio","inputAudio","processEvent","args","event_id","console","error","eventProcessor","call","getItem","getItems"],"sources":["/Users/michaelmccarthy/Desktop/work_local/nxt_humans/projects/nxt-hackathon-front-end-app/node_modules/@openai/realtime-api-beta/lib/conversation.js"],"sourcesContent":["import { RealtimeUtils } from './utils.js';\n\n/**\n * Contains text and audio information about a item\n * Can also be used as a delta\n * @typedef {Object} ItemContentDeltaType\n * @property {string} [text]\n * @property {Int16Array} [audio]\n * @property {string} [arguments]\n * @property {string} [transcript]\n */\n\n/**\n * RealtimeConversation holds conversation history\n * and performs event validation for RealtimeAPI\n * @class\n */\nexport class RealtimeConversation {\n  defaultFrequency = 24_000; // 24,000 Hz\n\n  EventProcessors = {\n    'conversation.item.created': (event) => {\n      const { item } = event;\n      // deep copy values\n      const newItem = JSON.parse(JSON.stringify(item));\n      if (!this.itemLookup[newItem.id]) {\n        this.itemLookup[newItem.id] = newItem;\n        this.items.push(newItem);\n      }\n      newItem.formatted = {};\n      newItem.formatted.audio = new Int16Array(0);\n      newItem.formatted.text = '';\n      newItem.formatted.transcript = '';\n      // If we have a speech item, can populate audio\n      if (this.queuedSpeechItems[newItem.id]) {\n        newItem.formatted.audio = this.queuedSpeechItems[newItem.id].audio;\n        delete this.queuedSpeechItems[newItem.id]; // free up some memory\n      }\n      // Populate formatted text if it comes out on creation\n      if (newItem.content) {\n        const textContent = newItem.content.filter((c) =>\n          ['text', 'input_text'].includes(c.type),\n        );\n        for (const content of textContent) {\n          newItem.formatted.text += content.text;\n        }\n      }\n      // If we have a transcript item, can pre-populate transcript\n      if (this.queuedTranscriptItems[newItem.id]) {\n        newItem.formatted.transcript = this.queuedTranscriptItems.transcript;\n        delete this.queuedTranscriptItems[newItem.id];\n      }\n      if (newItem.type === 'message') {\n        if (newItem.role === 'user') {\n          newItem.status = 'completed';\n          if (this.queuedInputAudio) {\n            newItem.formatted.audio = this.queuedInputAudio;\n            this.queuedInputAudio = null;\n          }\n        } else {\n          newItem.status = 'in_progress';\n        }\n      } else if (newItem.type === 'function_call') {\n        newItem.formatted.tool = {\n          type: 'function',\n          name: newItem.name,\n          call_id: newItem.call_id,\n          arguments: '',\n        };\n        newItem.status = 'in_progress';\n      } else if (newItem.type === 'function_call_output') {\n        newItem.status = 'completed';\n        newItem.formatted.output = newItem.output;\n      }\n      return { item: newItem, delta: null };\n    },\n    'conversation.item.truncated': (event) => {\n      const { item_id, audio_end_ms } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(`item.truncated: Item \"${item_id}\" not found`);\n      }\n      const endIndex = Math.floor(\n        (audio_end_ms * this.defaultFrequency) / 1000,\n      );\n      item.formatted.transcript = '';\n      item.formatted.audio = item.formatted.audio.slice(0, endIndex);\n      return { item, delta: null };\n    },\n    'conversation.item.deleted': (event) => {\n      const { item_id } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(`item.deleted: Item \"${item_id}\" not found`);\n      }\n      delete this.itemLookup[item.id];\n      const index = this.items.indexOf(item);\n      if (index > -1) {\n        this.items.splice(index, 1);\n      }\n      return { item, delta: null };\n    },\n    'conversation.item.input_audio_transcription.completed': (event) => {\n      const { item_id, content_index, transcript } = event;\n      const item = this.itemLookup[item_id];\n      // We use a single space to represent an empty transcript for .formatted values\n      // Otherwise it looks like no transcript provided\n      const formattedTranscript = transcript || ' ';\n      if (!item) {\n        // We can receive transcripts in VAD mode before item.created\n        // This happens specifically when audio is empty\n        this.queuedTranscriptItems[item_id] = {\n          transcript: formattedTranscript,\n        };\n        return { item: null, delta: null };\n      } else {\n        item.content[content_index].transcript = transcript;\n        item.formatted.transcript = formattedTranscript;\n        return { item, delta: { transcript } };\n      }\n    },\n    'input_audio_buffer.speech_started': (event) => {\n      const { item_id, audio_start_ms } = event;\n      this.queuedSpeechItems[item_id] = { audio_start_ms };\n      return { item: null, delta: null };\n    },\n    'input_audio_buffer.speech_stopped': (event, inputAudioBuffer) => {\n      const { item_id, audio_end_ms } = event;\n      const speech = this.queuedSpeechItems[item_id];\n      speech.audio_end_ms = audio_end_ms;\n      if (inputAudioBuffer) {\n        const startIndex = Math.floor(\n          (speech.audio_start_ms * this.defaultFrequency) / 1000,\n        );\n        const endIndex = Math.floor(\n          (speech.audio_end_ms * this.defaultFrequency) / 1000,\n        );\n        speech.audio = inputAudioBuffer.slice(startIndex, endIndex);\n      }\n      return { item: null, delta: null };\n    },\n    'response.created': (event) => {\n      const { response } = event;\n      if (!this.responseLookup[response.id]) {\n        this.responseLookup[response.id] = response;\n        this.responses.push(response);\n      }\n      return { item: null, delta: null };\n    },\n    'response.output_item.added': (event) => {\n      const { response_id, item } = event;\n      const response = this.responseLookup[response_id];\n      if (!response) {\n        throw new Error(\n          `response.output_item.added: Response \"${response_id}\" not found`,\n        );\n      }\n      response.output.push(item.id);\n      return { item: null, delta: null };\n    },\n    'response.output_item.done': (event) => {\n      const { item } = event;\n      if (!item) {\n        throw new Error(`response.output_item.done: Missing \"item\"`);\n      }\n      const foundItem = this.itemLookup[item.id];\n      if (!foundItem) {\n        throw new Error(\n          `response.output_item.done: Item \"${item.id}\" not found`,\n        );\n      }\n      foundItem.status = item.status;\n      return { item: foundItem, delta: null };\n    },\n    'response.content_part.added': (event) => {\n      const { item_id, part } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(\n          `response.content_part.added: Item \"${item_id}\" not found`,\n        );\n      }\n      item.content.push(part);\n      return { item, delta: null };\n    },\n    'response.audio_transcript.delta': (event) => {\n      const { item_id, content_index, delta } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(\n          `response.audio_transcript.delta: Item \"${item_id}\" not found`,\n        );\n      }\n      item.content[content_index].transcript += delta;\n      item.formatted.transcript += delta;\n      return { item, delta: { transcript: delta } };\n    },\n    'response.audio.delta': (event) => {\n      const { item_id, content_index, delta } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(`response.audio.delta: Item \"${item_id}\" not found`);\n      }\n      // This never gets renderered, we care about the file data instead\n      // item.content[content_index].audio += delta;\n      const arrayBuffer = RealtimeUtils.base64ToArrayBuffer(delta);\n      const appendValues = new Int16Array(arrayBuffer);\n      item.formatted.audio = RealtimeUtils.mergeInt16Arrays(\n        item.formatted.audio,\n        appendValues,\n      );\n      return { item, delta: { audio: appendValues } };\n    },\n    'response.text.delta': (event) => {\n      const { item_id, content_index, delta } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(`response.text.delta: Item \"${item_id}\" not found`);\n      }\n      item.content[content_index].text += delta;\n      item.formatted.text += delta;\n      return { item, delta: { text: delta } };\n    },\n    'response.function_call_arguments.delta': (event) => {\n      const { item_id, delta } = event;\n      const item = this.itemLookup[item_id];\n      if (!item) {\n        throw new Error(\n          `response.function_call_arguments.delta: Item \"${item_id}\" not found`,\n        );\n      }\n      item.arguments += delta;\n      item.formatted.tool.arguments += delta;\n      return { item, delta: { arguments: delta } };\n    },\n  };\n\n  /**\n   * Create a new RealtimeConversation instance\n   * @returns {RealtimeConversation}\n   */\n  constructor() {\n    this.clear();\n  }\n\n  /**\n   * Clears the conversation history and resets to default\n   * @returns {true}\n   */\n  clear() {\n    this.itemLookup = {};\n    this.items = [];\n    this.responseLookup = {};\n    this.responses = [];\n    this.queuedSpeechItems = {};\n    this.queuedTranscriptItems = {};\n    this.queuedInputAudio = null;\n    return true;\n  }\n\n  /**\n   * Queue input audio for manual speech event\n   * @param {Int16Array} inputAudio\n   * @returns {Int16Array}\n   */\n  queueInputAudio(inputAudio) {\n    this.queuedInputAudio = inputAudio;\n    return inputAudio;\n  }\n\n  /**\n   * Process an event from the WebSocket server and compose items\n   * @param {Object} event\n   * @param  {...any} args\n   * @returns {item: import('./client.js').ItemType | null, delta: ItemContentDeltaType | null}\n   */\n  processEvent(event, ...args) {\n    if (!event.event_id) {\n      console.error(event);\n      throw new Error(`Missing \"event_id\" on event`);\n    }\n    if (!event.type) {\n      console.error(event);\n      throw new Error(`Missing \"type\" on event`);\n    }\n    const eventProcessor = this.EventProcessors[event.type];\n    if (!eventProcessor) {\n      throw new Error(\n        `Missing conversation event processor for \"${event.type}\"`,\n      );\n    }\n    return eventProcessor.call(this, event, ...args);\n  }\n\n  /**\n   * Retrieves a item by id\n   * @param {string} id\n   * @returns {import('./client.js').ItemType}\n   */\n  getItem(id) {\n    return this.itemLookup[id] || null;\n  }\n\n  /**\n   * Retrieves all items in the conversation\n   * @returns {import('./client.js').ItemType[]}\n   */\n  getItems() {\n    return this.items.slice();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}