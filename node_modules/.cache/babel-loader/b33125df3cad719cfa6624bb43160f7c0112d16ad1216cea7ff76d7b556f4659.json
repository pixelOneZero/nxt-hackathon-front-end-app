{"ast":null,"code":"/**\n * Raw wav audio file contents\n * @typedef {Object} WavPackerAudioType\n * @property {Blob} blob\n * @property {string} url\n * @property {number} channelCount\n * @property {number} sampleRate\n * @property {number} duration\n */\n\n/**\n * Utility class for assembling PCM16 \"audio/wav\" data\n * @class\n */\nexport class WavPacker {\n  /**\n   * Converts Float32Array of amplitude data to ArrayBuffer in Int16Array format\n   * @param {Float32Array} float32Array\n   * @returns {ArrayBuffer}\n   */\n  static floatTo16BitPCM(float32Array) {\n    const buffer = new ArrayBuffer(float32Array.length * 2);\n    const view = new DataView(buffer);\n    let offset = 0;\n    for (let i = 0; i < float32Array.length; i++, offset += 2) {\n      let s = Math.max(-1, Math.min(1, float32Array[i]));\n      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n    }\n    return buffer;\n  }\n\n  /**\n   * Concatenates two ArrayBuffers\n   * @param {ArrayBuffer} leftBuffer\n   * @param {ArrayBuffer} rightBuffer\n   * @returns {ArrayBuffer}\n   */\n  static mergeBuffers(leftBuffer, rightBuffer) {\n    const tmpArray = new Uint8Array(leftBuffer.byteLength + rightBuffer.byteLength);\n    tmpArray.set(new Uint8Array(leftBuffer), 0);\n    tmpArray.set(new Uint8Array(rightBuffer), leftBuffer.byteLength);\n    return tmpArray.buffer;\n  }\n\n  /**\n   * Packs data into an Int16 format\n   * @private\n   * @param {number} size 0 = 1x Int16, 1 = 2x Int16\n   * @param {number} arg value to pack\n   * @returns\n   */\n  _packData(size, arg) {\n    return [new Uint8Array([arg, arg >> 8]), new Uint8Array([arg, arg >> 8, arg >> 16, arg >> 24])][size];\n  }\n\n  /**\n   * Packs audio into \"audio/wav\" Blob\n   * @param {number} sampleRate\n   * @param {{bitsPerSample: number, channels: Array<Float32Array>, data: Int16Array}} audio\n   * @returns {WavPackerAudioType}\n   */\n  pack(sampleRate, audio) {\n    if (!(audio !== null && audio !== void 0 && audio.bitsPerSample)) {\n      throw new Error(`Missing \"bitsPerSample\"`);\n    } else if (!(audio !== null && audio !== void 0 && audio.channels)) {\n      throw new Error(`Missing \"channels\"`);\n    } else if (!(audio !== null && audio !== void 0 && audio.data)) {\n      throw new Error(`Missing \"data\"`);\n    }\n    const {\n      bitsPerSample,\n      channels,\n      data\n    } = audio;\n    const output = [\n    // Header\n    'RIFF', this._packData(1, 4 + (8 + 24) /* chunk 1 length */ + (8 + 8) /* chunk 2 length */),\n    // Length\n    'WAVE',\n    // chunk 1\n    'fmt ',\n    // Sub-chunk identifier\n    this._packData(1, 16),\n    // Chunk length\n    this._packData(0, 1),\n    // Audio format (1 is linear quantization)\n    this._packData(0, channels.length), this._packData(1, sampleRate), this._packData(1, sampleRate * channels.length * bitsPerSample / 8),\n    // Byte rate\n    this._packData(0, channels.length * bitsPerSample / 8), this._packData(0, bitsPerSample),\n    // chunk 2\n    'data',\n    // Sub-chunk identifier\n    this._packData(1, channels[0].length * channels.length * bitsPerSample / 8),\n    // Chunk length\n    data];\n    const blob = new Blob(output, {\n      type: 'audio/mpeg'\n    });\n    const url = URL.createObjectURL(blob);\n    return {\n      blob,\n      url,\n      channelCount: channels.length,\n      sampleRate,\n      duration: data.byteLength / (channels.length * sampleRate * 2)\n    };\n  }\n}\nglobalThis.WavPacker = WavPacker;","map":{"version":3,"names":["WavPacker","floatTo16BitPCM","float32Array","buffer","ArrayBuffer","length","view","DataView","offset","i","s","Math","max","min","setInt16","mergeBuffers","leftBuffer","rightBuffer","tmpArray","Uint8Array","byteLength","set","_packData","size","arg","pack","sampleRate","audio","bitsPerSample","Error","channels","data","output","blob","Blob","type","url","URL","createObjectURL","channelCount","duration","globalThis"],"sources":["/Users/michaelmccarthy/Desktop/work_local/nxt_humans/projects/nxt-hackathon-front-end-app/src/lib/wavtools/lib/wav_packer.js"],"sourcesContent":["/**\n * Raw wav audio file contents\n * @typedef {Object} WavPackerAudioType\n * @property {Blob} blob\n * @property {string} url\n * @property {number} channelCount\n * @property {number} sampleRate\n * @property {number} duration\n */\n\n/**\n * Utility class for assembling PCM16 \"audio/wav\" data\n * @class\n */\nexport class WavPacker {\n  /**\n   * Converts Float32Array of amplitude data to ArrayBuffer in Int16Array format\n   * @param {Float32Array} float32Array\n   * @returns {ArrayBuffer}\n   */\n  static floatTo16BitPCM(float32Array) {\n    const buffer = new ArrayBuffer(float32Array.length * 2);\n    const view = new DataView(buffer);\n    let offset = 0;\n    for (let i = 0; i < float32Array.length; i++, offset += 2) {\n      let s = Math.max(-1, Math.min(1, float32Array[i]));\n      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n    }\n    return buffer;\n  }\n\n  /**\n   * Concatenates two ArrayBuffers\n   * @param {ArrayBuffer} leftBuffer\n   * @param {ArrayBuffer} rightBuffer\n   * @returns {ArrayBuffer}\n   */\n  static mergeBuffers(leftBuffer, rightBuffer) {\n    const tmpArray = new Uint8Array(\n      leftBuffer.byteLength + rightBuffer.byteLength\n    );\n    tmpArray.set(new Uint8Array(leftBuffer), 0);\n    tmpArray.set(new Uint8Array(rightBuffer), leftBuffer.byteLength);\n    return tmpArray.buffer;\n  }\n\n  /**\n   * Packs data into an Int16 format\n   * @private\n   * @param {number} size 0 = 1x Int16, 1 = 2x Int16\n   * @param {number} arg value to pack\n   * @returns\n   */\n  _packData(size, arg) {\n    return [\n      new Uint8Array([arg, arg >> 8]),\n      new Uint8Array([arg, arg >> 8, arg >> 16, arg >> 24]),\n    ][size];\n  }\n\n  /**\n   * Packs audio into \"audio/wav\" Blob\n   * @param {number} sampleRate\n   * @param {{bitsPerSample: number, channels: Array<Float32Array>, data: Int16Array}} audio\n   * @returns {WavPackerAudioType}\n   */\n  pack(sampleRate, audio) {\n    if (!audio?.bitsPerSample) {\n      throw new Error(`Missing \"bitsPerSample\"`);\n    } else if (!audio?.channels) {\n      throw new Error(`Missing \"channels\"`);\n    } else if (!audio?.data) {\n      throw new Error(`Missing \"data\"`);\n    }\n    const { bitsPerSample, channels, data } = audio;\n    const output = [\n      // Header\n      'RIFF',\n      this._packData(\n        1,\n        4 + (8 + 24) /* chunk 1 length */ + (8 + 8) /* chunk 2 length */\n      ), // Length\n      'WAVE',\n      // chunk 1\n      'fmt ', // Sub-chunk identifier\n      this._packData(1, 16), // Chunk length\n      this._packData(0, 1), // Audio format (1 is linear quantization)\n      this._packData(0, channels.length),\n      this._packData(1, sampleRate),\n      this._packData(1, (sampleRate * channels.length * bitsPerSample) / 8), // Byte rate\n      this._packData(0, (channels.length * bitsPerSample) / 8),\n      this._packData(0, bitsPerSample),\n      // chunk 2\n      'data', // Sub-chunk identifier\n      this._packData(\n        1,\n        (channels[0].length * channels.length * bitsPerSample) / 8\n      ), // Chunk length\n      data,\n    ];\n    const blob = new Blob(output, { type: 'audio/mpeg' });\n    const url = URL.createObjectURL(blob);\n    return {\n      blob,\n      url,\n      channelCount: channels.length,\n      sampleRate,\n      duration: data.byteLength / (channels.length * sampleRate * 2),\n    };\n  }\n}\n\nglobalThis.WavPacker = WavPacker;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}