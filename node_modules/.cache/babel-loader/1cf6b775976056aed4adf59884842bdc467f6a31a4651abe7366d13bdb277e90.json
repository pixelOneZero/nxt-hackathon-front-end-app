{"ast":null,"code":"/* eslint-disable no-undef */\n\nimport { AudioProcessorSrc } from './worklets/audio_processor.js';\nimport { AudioAnalysis } from './analysis/audio_analysis.js';\nimport { WavPacker } from './wav_packer.js';\n\n/**\n * Decodes audio into a wav file\n * @typedef {Object} DecodedAudioType\n * @property {Blob} blob\n * @property {string} url\n * @property {Float32Array} values\n * @property {AudioBuffer} audioBuffer\n */\n\n/**\n * Records live stream of user audio as PCM16 \"audio/wav\" data\n * @class\n */\nexport class WavRecorder {\n  /**\n   * Create a new WavRecorder instance\n   * @param {{sampleRate?: number, outputToSpeakers?: boolean, debug?: boolean}} [options]\n   * @returns {WavRecorder}\n   */\n  constructor({\n    sampleRate = 44100,\n    outputToSpeakers = false,\n    debug = false\n  } = {}) {\n    // Script source\n    this.scriptSrc = AudioProcessorSrc;\n    // Config\n    this.sampleRate = sampleRate;\n    this.outputToSpeakers = outputToSpeakers;\n    this.debug = !!debug;\n    this._deviceChangeCallback = null;\n    this._devices = [];\n    // State variables\n    this.stream = null;\n    this.processor = null;\n    this.source = null;\n    this.node = null;\n    this.recording = false;\n    // Event handling with AudioWorklet\n    this._lastEventId = 0;\n    this.eventReceipts = {};\n    this.eventTimeout = 5000;\n    // Process chunks of audio\n    this._chunkProcessor = () => {};\n    this._chunkProcessorSize = void 0;\n    this._chunkProcessorBuffer = {\n      raw: new ArrayBuffer(0),\n      mono: new ArrayBuffer(0)\n    };\n  }\n\n  /**\n   * Decodes audio data from multiple formats to a Blob, url, Float32Array and AudioBuffer\n   * @param {Blob|Float32Array|Int16Array|ArrayBuffer|number[]} audioData\n   * @param {number} sampleRate\n   * @param {number} fromSampleRate\n   * @returns {Promise<DecodedAudioType>}\n   */\n  static async decode(audioData, sampleRate = 44100, fromSampleRate = -1) {\n    const context = new AudioContext({\n      sampleRate\n    });\n    let arrayBuffer;\n    let blob;\n    if (audioData instanceof Blob) {\n      if (fromSampleRate !== -1) {\n        throw new Error(`Can not specify \"fromSampleRate\" when reading from Blob`);\n      }\n      blob = audioData;\n      arrayBuffer = await blob.arrayBuffer();\n    } else if (audioData instanceof ArrayBuffer) {\n      if (fromSampleRate !== -1) {\n        throw new Error(`Can not specify \"fromSampleRate\" when reading from ArrayBuffer`);\n      }\n      arrayBuffer = audioData;\n      blob = new Blob([arrayBuffer], {\n        type: 'audio/wav'\n      });\n    } else {\n      let float32Array;\n      let data;\n      if (audioData instanceof Int16Array) {\n        data = audioData;\n        float32Array = new Float32Array(audioData.length);\n        for (let i = 0; i < audioData.length; i++) {\n          float32Array[i] = audioData[i] / 0x8000;\n        }\n      } else if (audioData instanceof Float32Array) {\n        float32Array = audioData;\n      } else if (audioData instanceof Array) {\n        float32Array = new Float32Array(audioData);\n      } else {\n        throw new Error(`\"audioData\" must be one of: Blob, Float32Arrray, Int16Array, ArrayBuffer, Array<number>`);\n      }\n      if (fromSampleRate === -1) {\n        throw new Error(`Must specify \"fromSampleRate\" when reading from Float32Array, In16Array or Array`);\n      } else if (fromSampleRate < 3000) {\n        throw new Error(`Minimum \"fromSampleRate\" is 3000 (3kHz)`);\n      }\n      if (!data) {\n        data = WavPacker.floatTo16BitPCM(float32Array);\n      }\n      const audio = {\n        bitsPerSample: 16,\n        channels: [float32Array],\n        data\n      };\n      const packer = new WavPacker();\n      const result = packer.pack(fromSampleRate, audio);\n      blob = result.blob;\n      arrayBuffer = await blob.arrayBuffer();\n    }\n    const audioBuffer = await context.decodeAudioData(arrayBuffer);\n    const values = audioBuffer.getChannelData(0);\n    const url = URL.createObjectURL(blob);\n    return {\n      blob,\n      url,\n      values,\n      audioBuffer\n    };\n  }\n\n  /**\n   * Logs data in debug mode\n   * @param {...any} arguments\n   * @returns {true}\n   */\n  log() {\n    if (this.debug) {\n      this.log(...arguments);\n    }\n    return true;\n  }\n\n  /**\n   * Retrieves the current sampleRate for the recorder\n   * @returns {number}\n   */\n  getSampleRate() {\n    return this.sampleRate;\n  }\n\n  /**\n   * Retrieves the current status of the recording\n   * @returns {\"ended\"|\"paused\"|\"recording\"}\n   */\n  getStatus() {\n    if (!this.processor) {\n      return 'ended';\n    } else if (!this.recording) {\n      return 'paused';\n    } else {\n      return 'recording';\n    }\n  }\n\n  /**\n   * Sends an event to the AudioWorklet\n   * @private\n   * @param {string} name\n   * @param {{[key: string]: any}} data\n   * @param {AudioWorkletNode} [_processor]\n   * @returns {Promise<{[key: string]: any}>}\n   */\n  async _event(name, data = {}, _processor = null) {\n    _processor = _processor || this.processor;\n    if (!_processor) {\n      throw new Error('Can not send events without recording first');\n    }\n    const message = {\n      event: name,\n      id: this._lastEventId++,\n      data\n    };\n    _processor.port.postMessage(message);\n    const t0 = new Date().valueOf();\n    while (!this.eventReceipts[message.id]) {\n      if (new Date().valueOf() - t0 > this.eventTimeout) {\n        throw new Error(`Timeout waiting for \"${name}\" event`);\n      }\n      await new Promise(res => setTimeout(() => res(true), 1));\n    }\n    const payload = this.eventReceipts[message.id];\n    delete this.eventReceipts[message.id];\n    return payload;\n  }\n\n  /**\n   * Sets device change callback, remove if callback provided is `null`\n   * @param {(Array<MediaDeviceInfo & {default: boolean}>): void|null} callback\n   * @returns {true}\n   */\n  listenForDeviceChange(callback) {\n    if (callback === null && this._deviceChangeCallback) {\n      navigator.mediaDevices.removeEventListener('devicechange', this._deviceChangeCallback);\n      this._deviceChangeCallback = null;\n    } else if (callback !== null) {\n      // Basically a debounce; we only want this called once when devices change\n      // And we only want the most recent callback() to be executed\n      // if a few are operating at the same time\n      let lastId = 0;\n      let lastDevices = [];\n      const serializeDevices = devices => devices.map(d => d.deviceId).sort().join(',');\n      const cb = async () => {\n        let id = ++lastId;\n        const devices = await this.listDevices();\n        if (id === lastId) {\n          if (serializeDevices(lastDevices) !== serializeDevices(devices)) {\n            lastDevices = devices;\n            callback(devices.slice());\n          }\n        }\n      };\n      navigator.mediaDevices.addEventListener('devicechange', cb);\n      cb();\n      this._deviceChangeCallback = cb;\n    }\n    return true;\n  }\n\n  /**\n   * Manually request permission to use the microphone\n   * @returns {Promise<true>}\n   */\n  async requestPermission() {\n    const permissionStatus = await navigator.permissions.query({\n      name: 'microphone'\n    });\n    if (permissionStatus.state === 'denied') {\n      window.alert('You must grant microphone access to use this feature.');\n    } else if (permissionStatus.state === 'prompt') {\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({\n          audio: true\n        });\n        const tracks = stream.getTracks();\n        tracks.forEach(track => track.stop());\n      } catch (e) {\n        window.alert('You must grant microphone access to use this feature.');\n      }\n    }\n    return true;\n  }\n\n  /**\n   * List all eligible devices for recording, will request permission to use microphone\n   * @returns {Promise<Array<MediaDeviceInfo & {default: boolean}>>}\n   */\n  async listDevices() {\n    if (!navigator.mediaDevices || !('enumerateDevices' in navigator.mediaDevices)) {\n      throw new Error('Could not request user devices');\n    }\n    await this.requestPermission();\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const audioDevices = devices.filter(device => device.kind === 'audioinput');\n    const defaultDeviceIndex = audioDevices.findIndex(device => device.deviceId === 'default');\n    const deviceList = [];\n    if (defaultDeviceIndex !== -1) {\n      let defaultDevice = audioDevices.splice(defaultDeviceIndex, 1)[0];\n      let existingIndex = audioDevices.findIndex(device => device.groupId === defaultDevice.groupId);\n      if (existingIndex !== -1) {\n        defaultDevice = audioDevices.splice(existingIndex, 1)[0];\n      }\n      defaultDevice.default = true;\n      deviceList.push(defaultDevice);\n    }\n    return deviceList.concat(audioDevices);\n  }\n\n  /**\n   * Begins a recording session and requests microphone permissions if not already granted\n   * Microphone recording indicator will appear on browser tab but status will be \"paused\"\n   * @param {string} [deviceId] if no device provided, default device will be used\n   * @returns {Promise<true>}\n   */\n  async begin(deviceId) {\n    if (this.processor) {\n      throw new Error(`Already connected: please call .end() to start a new session`);\n    }\n    if (!navigator.mediaDevices || !('getUserMedia' in navigator.mediaDevices)) {\n      throw new Error('Could not request user media');\n    }\n    try {\n      const config = {\n        audio: true\n      };\n      if (deviceId) {\n        config.audio = {\n          deviceId: {\n            exact: deviceId\n          }\n        };\n      }\n      this.stream = await navigator.mediaDevices.getUserMedia(config);\n    } catch (err) {\n      throw new Error('Could not start media stream');\n    }\n    const context = new AudioContext({\n      sampleRate: this.sampleRate\n    });\n    const source = context.createMediaStreamSource(this.stream);\n    // Load and execute the module script.\n    try {\n      await context.audioWorklet.addModule(this.scriptSrc);\n    } catch (e) {\n      console.error(e);\n      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);\n    }\n    const processor = new AudioWorkletNode(context, 'audio_processor');\n    processor.port.onmessage = e => {\n      const {\n        event,\n        id,\n        data\n      } = e.data;\n      if (event === 'receipt') {\n        this.eventReceipts[id] = data;\n      } else if (event === 'chunk') {\n        if (this._chunkProcessorSize) {\n          const buffer = this._chunkProcessorBuffer;\n          this._chunkProcessorBuffer = {\n            raw: WavPacker.mergeBuffers(buffer.raw, data.raw),\n            mono: WavPacker.mergeBuffers(buffer.mono, data.mono)\n          };\n          if (this._chunkProcessorBuffer.mono.byteLength >= this._chunkProcessorSize) {\n            this._chunkProcessor(this._chunkProcessorBuffer);\n            this._chunkProcessorBuffer = {\n              raw: new ArrayBuffer(0),\n              mono: new ArrayBuffer(0)\n            };\n          }\n        } else {\n          this._chunkProcessor(data);\n        }\n      }\n    };\n    const node = source.connect(processor);\n    const analyser = context.createAnalyser();\n    analyser.fftSize = 8192;\n    analyser.smoothingTimeConstant = 0.1;\n    node.connect(analyser);\n    if (this.outputToSpeakers) {\n      // eslint-disable-next-line no-console\n      console.warn('Warning: Output to speakers may affect sound quality,\\n' + 'especially due to system audio feedback preventative measures.\\n' + 'use only for debugging');\n      analyser.connect(context.destination);\n    }\n    this.source = source;\n    this.node = node;\n    this.analyser = analyser;\n    this.processor = processor;\n    return true;\n  }\n\n  /**\n   * Gets the current frequency domain data from the recording track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}\n   */\n  getFrequencies(analysisType = 'frequency', minDecibels = -100, maxDecibels = -30) {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    return AudioAnalysis.getFrequencies(this.analyser, this.sampleRate, null, analysisType, minDecibels, maxDecibels);\n  }\n\n  /**\n   * Pauses the recording\n   * Keeps microphone stream open but halts storage of audio\n   * @returns {Promise<true>}\n   */\n  async pause() {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    } else if (!this.recording) {\n      throw new Error('Already paused: please call .record() first');\n    }\n    if (this._chunkProcessorBuffer.raw.byteLength) {\n      this._chunkProcessor(this._chunkProcessorBuffer);\n    }\n    this.log('Pausing ...');\n    await this._event('stop');\n    this.recording = false;\n    return true;\n  }\n\n  /**\n   * Start recording stream and storing to memory from the connected audio source\n   * @param {(data: { mono: Int16Array; raw: Int16Array }) => any} [chunkProcessor]\n   * @param {number} [chunkSize] chunkProcessor will not be triggered until this size threshold met in mono audio\n   * @returns {Promise<true>}\n   */\n  async record(chunkProcessor = () => {}, chunkSize = 8192) {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    } else if (this.recording) {\n      throw new Error('Already recording: please call .pause() first');\n    } else if (typeof chunkProcessor !== 'function') {\n      throw new Error(`chunkProcessor must be a function`);\n    }\n    this._chunkProcessor = chunkProcessor;\n    this._chunkProcessorSize = chunkSize;\n    this._chunkProcessorBuffer = {\n      raw: new ArrayBuffer(0),\n      mono: new ArrayBuffer(0)\n    };\n    this.log('Recording ...');\n    await this._event('start');\n    this.recording = true;\n    return true;\n  }\n\n  /**\n   * Clears the audio buffer, empties stored recording\n   * @returns {Promise<true>}\n   */\n  async clear() {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    await this._event('clear');\n    return true;\n  }\n\n  /**\n   * Reads the current audio stream data\n   * @returns {Promise<{meanValues: Float32Array, channels: Array<Float32Array>}>}\n   */\n  async read() {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    this.log('Reading ...');\n    const result = await this._event('read');\n    return result;\n  }\n\n  /**\n   * Saves the current audio stream to a file\n   * @param {boolean} [force] Force saving while still recording\n   * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}\n   */\n  async save(force = false) {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    if (!force && this.recording) {\n      throw new Error('Currently recording: please call .pause() first, or call .save(true) to force');\n    }\n    this.log('Exporting ...');\n    const exportData = await this._event('export');\n    const packer = new WavPacker();\n    const result = packer.pack(this.sampleRate, exportData.audio);\n    return result;\n  }\n\n  /**\n   * Ends the current recording session and saves the result\n   * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}\n   */\n  async end() {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    const _processor = this.processor;\n    this.log('Stopping ...');\n    await this._event('stop');\n    this.recording = false;\n    const tracks = this.stream.getTracks();\n    tracks.forEach(track => track.stop());\n    this.log('Exporting ...');\n    const exportData = await this._event('export', {}, _processor);\n    this.processor.disconnect();\n    this.source.disconnect();\n    this.node.disconnect();\n    this.analyser.disconnect();\n    this.stream = null;\n    this.processor = null;\n    this.source = null;\n    this.node = null;\n    const packer = new WavPacker();\n    const result = packer.pack(this.sampleRate, exportData.audio);\n    return result;\n  }\n\n  /**\n   * Performs a full cleanup of WavRecorder instance\n   * Stops actively listening via microphone and removes existing listeners\n   * @returns {Promise<true>}\n   */\n  async quit() {\n    this.listenForDeviceChange(null);\n    if (this.processor) {\n      await this.end();\n    }\n    return true;\n  }\n}\nglobalThis.WavRecorder = WavRecorder;","map":{"version":3,"names":["AudioProcessorSrc","AudioAnalysis","WavPacker","WavRecorder","constructor","sampleRate","outputToSpeakers","debug","scriptSrc","_deviceChangeCallback","_devices","stream","processor","source","node","recording","_lastEventId","eventReceipts","eventTimeout","_chunkProcessor","_chunkProcessorSize","_chunkProcessorBuffer","raw","ArrayBuffer","mono","decode","audioData","fromSampleRate","context","AudioContext","arrayBuffer","blob","Blob","Error","type","float32Array","data","Int16Array","Float32Array","length","i","Array","floatTo16BitPCM","audio","bitsPerSample","channels","packer","result","pack","audioBuffer","decodeAudioData","values","getChannelData","url","URL","createObjectURL","log","arguments","getSampleRate","getStatus","_event","name","_processor","message","event","id","port","postMessage","t0","Date","valueOf","Promise","res","setTimeout","payload","listenForDeviceChange","callback","navigator","mediaDevices","removeEventListener","lastId","lastDevices","serializeDevices","devices","map","d","deviceId","sort","join","cb","listDevices","slice","addEventListener","requestPermission","permissionStatus","permissions","query","state","window","alert","getUserMedia","tracks","getTracks","forEach","track","stop","e","enumerateDevices","audioDevices","filter","device","kind","defaultDeviceIndex","findIndex","deviceList","defaultDevice","splice","existingIndex","groupId","default","push","concat","begin","config","exact","err","createMediaStreamSource","audioWorklet","addModule","console","error","AudioWorkletNode","onmessage","buffer","mergeBuffers","byteLength","connect","analyser","createAnalyser","fftSize","smoothingTimeConstant","warn","destination","getFrequencies","analysisType","minDecibels","maxDecibels","pause","record","chunkProcessor","chunkSize","clear","read","save","force","exportData","end","disconnect","quit","globalThis"],"sources":["/Users/michaelmccarthy/Desktop/work_local/nxt_humans/projects/nxt-hackathon-front-end-app/src/lib/wavtools/lib/wav_recorder.js"],"sourcesContent":["/* eslint-disable no-undef */\n\nimport { AudioProcessorSrc } from './worklets/audio_processor.js';\nimport { AudioAnalysis } from './analysis/audio_analysis.js';\nimport { WavPacker } from './wav_packer.js';\n\n/**\n * Decodes audio into a wav file\n * @typedef {Object} DecodedAudioType\n * @property {Blob} blob\n * @property {string} url\n * @property {Float32Array} values\n * @property {AudioBuffer} audioBuffer\n */\n\n/**\n * Records live stream of user audio as PCM16 \"audio/wav\" data\n * @class\n */\nexport class WavRecorder {\n  /**\n   * Create a new WavRecorder instance\n   * @param {{sampleRate?: number, outputToSpeakers?: boolean, debug?: boolean}} [options]\n   * @returns {WavRecorder}\n   */\n  constructor({\n    sampleRate = 44100,\n    outputToSpeakers = false,\n    debug = false,\n  } = {}) {\n    // Script source\n    this.scriptSrc = AudioProcessorSrc;\n    // Config\n    this.sampleRate = sampleRate;\n    this.outputToSpeakers = outputToSpeakers;\n    this.debug = !!debug;\n    this._deviceChangeCallback = null;\n    this._devices = [];\n    // State variables\n    this.stream = null;\n    this.processor = null;\n    this.source = null;\n    this.node = null;\n    this.recording = false;\n    // Event handling with AudioWorklet\n    this._lastEventId = 0;\n    this.eventReceipts = {};\n    this.eventTimeout = 5000;\n    // Process chunks of audio\n    this._chunkProcessor = () => {};\n    this._chunkProcessorSize = void 0;\n    this._chunkProcessorBuffer = {\n      raw: new ArrayBuffer(0),\n      mono: new ArrayBuffer(0),\n    };\n  }\n\n  /**\n   * Decodes audio data from multiple formats to a Blob, url, Float32Array and AudioBuffer\n   * @param {Blob|Float32Array|Int16Array|ArrayBuffer|number[]} audioData\n   * @param {number} sampleRate\n   * @param {number} fromSampleRate\n   * @returns {Promise<DecodedAudioType>}\n   */\n  static async decode(audioData, sampleRate = 44100, fromSampleRate = -1) {\n    const context = new AudioContext({ sampleRate });\n    let arrayBuffer;\n    let blob;\n    if (audioData instanceof Blob) {\n      if (fromSampleRate !== -1) {\n        throw new Error(\n          `Can not specify \"fromSampleRate\" when reading from Blob`,\n        );\n      }\n      blob = audioData;\n      arrayBuffer = await blob.arrayBuffer();\n    } else if (audioData instanceof ArrayBuffer) {\n      if (fromSampleRate !== -1) {\n        throw new Error(\n          `Can not specify \"fromSampleRate\" when reading from ArrayBuffer`,\n        );\n      }\n      arrayBuffer = audioData;\n      blob = new Blob([arrayBuffer], { type: 'audio/wav' });\n    } else {\n      let float32Array;\n      let data;\n      if (audioData instanceof Int16Array) {\n        data = audioData;\n        float32Array = new Float32Array(audioData.length);\n        for (let i = 0; i < audioData.length; i++) {\n          float32Array[i] = audioData[i] / 0x8000;\n        }\n      } else if (audioData instanceof Float32Array) {\n        float32Array = audioData;\n      } else if (audioData instanceof Array) {\n        float32Array = new Float32Array(audioData);\n      } else {\n        throw new Error(\n          `\"audioData\" must be one of: Blob, Float32Arrray, Int16Array, ArrayBuffer, Array<number>`,\n        );\n      }\n      if (fromSampleRate === -1) {\n        throw new Error(\n          `Must specify \"fromSampleRate\" when reading from Float32Array, In16Array or Array`,\n        );\n      } else if (fromSampleRate < 3000) {\n        throw new Error(`Minimum \"fromSampleRate\" is 3000 (3kHz)`);\n      }\n      if (!data) {\n        data = WavPacker.floatTo16BitPCM(float32Array);\n      }\n      const audio = {\n        bitsPerSample: 16,\n        channels: [float32Array],\n        data,\n      };\n      const packer = new WavPacker();\n      const result = packer.pack(fromSampleRate, audio);\n      blob = result.blob;\n      arrayBuffer = await blob.arrayBuffer();\n    }\n    const audioBuffer = await context.decodeAudioData(arrayBuffer);\n    const values = audioBuffer.getChannelData(0);\n    const url = URL.createObjectURL(blob);\n    return {\n      blob,\n      url,\n      values,\n      audioBuffer,\n    };\n  }\n\n  /**\n   * Logs data in debug mode\n   * @param {...any} arguments\n   * @returns {true}\n   */\n  log() {\n    if (this.debug) {\n      this.log(...arguments);\n    }\n    return true;\n  }\n\n  /**\n   * Retrieves the current sampleRate for the recorder\n   * @returns {number}\n   */\n  getSampleRate() {\n    return this.sampleRate;\n  }\n\n  /**\n   * Retrieves the current status of the recording\n   * @returns {\"ended\"|\"paused\"|\"recording\"}\n   */\n  getStatus() {\n    if (!this.processor) {\n      return 'ended';\n    } else if (!this.recording) {\n      return 'paused';\n    } else {\n      return 'recording';\n    }\n  }\n\n  /**\n   * Sends an event to the AudioWorklet\n   * @private\n   * @param {string} name\n   * @param {{[key: string]: any}} data\n   * @param {AudioWorkletNode} [_processor]\n   * @returns {Promise<{[key: string]: any}>}\n   */\n  async _event(name, data = {}, _processor = null) {\n    _processor = _processor || this.processor;\n    if (!_processor) {\n      throw new Error('Can not send events without recording first');\n    }\n    const message = {\n      event: name,\n      id: this._lastEventId++,\n      data,\n    };\n    _processor.port.postMessage(message);\n    const t0 = new Date().valueOf();\n    while (!this.eventReceipts[message.id]) {\n      if (new Date().valueOf() - t0 > this.eventTimeout) {\n        throw new Error(`Timeout waiting for \"${name}\" event`);\n      }\n      await new Promise((res) => setTimeout(() => res(true), 1));\n    }\n    const payload = this.eventReceipts[message.id];\n    delete this.eventReceipts[message.id];\n    return payload;\n  }\n\n  /**\n   * Sets device change callback, remove if callback provided is `null`\n   * @param {(Array<MediaDeviceInfo & {default: boolean}>): void|null} callback\n   * @returns {true}\n   */\n  listenForDeviceChange(callback) {\n    if (callback === null && this._deviceChangeCallback) {\n      navigator.mediaDevices.removeEventListener(\n        'devicechange',\n        this._deviceChangeCallback,\n      );\n      this._deviceChangeCallback = null;\n    } else if (callback !== null) {\n      // Basically a debounce; we only want this called once when devices change\n      // And we only want the most recent callback() to be executed\n      // if a few are operating at the same time\n      let lastId = 0;\n      let lastDevices = [];\n      const serializeDevices = (devices) =>\n        devices\n          .map((d) => d.deviceId)\n          .sort()\n          .join(',');\n      const cb = async () => {\n        let id = ++lastId;\n        const devices = await this.listDevices();\n        if (id === lastId) {\n          if (serializeDevices(lastDevices) !== serializeDevices(devices)) {\n            lastDevices = devices;\n            callback(devices.slice());\n          }\n        }\n      };\n      navigator.mediaDevices.addEventListener('devicechange', cb);\n      cb();\n      this._deviceChangeCallback = cb;\n    }\n    return true;\n  }\n\n  /**\n   * Manually request permission to use the microphone\n   * @returns {Promise<true>}\n   */\n  async requestPermission() {\n    const permissionStatus = await navigator.permissions.query({\n      name: 'microphone',\n    });\n    if (permissionStatus.state === 'denied') {\n      window.alert('You must grant microphone access to use this feature.');\n    } else if (permissionStatus.state === 'prompt') {\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({\n          audio: true,\n        });\n        const tracks = stream.getTracks();\n        tracks.forEach((track) => track.stop());\n      } catch (e) {\n        window.alert('You must grant microphone access to use this feature.');\n      }\n    }\n    return true;\n  }\n\n  /**\n   * List all eligible devices for recording, will request permission to use microphone\n   * @returns {Promise<Array<MediaDeviceInfo & {default: boolean}>>}\n   */\n  async listDevices() {\n    if (\n      !navigator.mediaDevices ||\n      !('enumerateDevices' in navigator.mediaDevices)\n    ) {\n      throw new Error('Could not request user devices');\n    }\n    await this.requestPermission();\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const audioDevices = devices.filter(\n      (device) => device.kind === 'audioinput',\n    );\n    const defaultDeviceIndex = audioDevices.findIndex(\n      (device) => device.deviceId === 'default',\n    );\n    const deviceList = [];\n    if (defaultDeviceIndex !== -1) {\n      let defaultDevice = audioDevices.splice(defaultDeviceIndex, 1)[0];\n      let existingIndex = audioDevices.findIndex(\n        (device) => device.groupId === defaultDevice.groupId,\n      );\n      if (existingIndex !== -1) {\n        defaultDevice = audioDevices.splice(existingIndex, 1)[0];\n      }\n      defaultDevice.default = true;\n      deviceList.push(defaultDevice);\n    }\n    return deviceList.concat(audioDevices);\n  }\n\n  /**\n   * Begins a recording session and requests microphone permissions if not already granted\n   * Microphone recording indicator will appear on browser tab but status will be \"paused\"\n   * @param {string} [deviceId] if no device provided, default device will be used\n   * @returns {Promise<true>}\n   */\n  async begin(deviceId) {\n    if (this.processor) {\n      throw new Error(\n        `Already connected: please call .end() to start a new session`,\n      );\n    }\n\n    if (\n      !navigator.mediaDevices ||\n      !('getUserMedia' in navigator.mediaDevices)\n    ) {\n      throw new Error('Could not request user media');\n    }\n    try {\n      const config = { audio: true };\n      if (deviceId) {\n        config.audio = { deviceId: { exact: deviceId } };\n      }\n      this.stream = await navigator.mediaDevices.getUserMedia(config);\n    } catch (err) {\n      throw new Error('Could not start media stream');\n    }\n\n    const context = new AudioContext({ sampleRate: this.sampleRate });\n    const source = context.createMediaStreamSource(this.stream);\n    // Load and execute the module script.\n    try {\n      await context.audioWorklet.addModule(this.scriptSrc);\n    } catch (e) {\n      console.error(e);\n      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);\n    }\n    const processor = new AudioWorkletNode(context, 'audio_processor');\n    processor.port.onmessage = (e) => {\n      const { event, id, data } = e.data;\n      if (event === 'receipt') {\n        this.eventReceipts[id] = data;\n      } else if (event === 'chunk') {\n        if (this._chunkProcessorSize) {\n          const buffer = this._chunkProcessorBuffer;\n          this._chunkProcessorBuffer = {\n            raw: WavPacker.mergeBuffers(buffer.raw, data.raw),\n            mono: WavPacker.mergeBuffers(buffer.mono, data.mono),\n          };\n          if (\n            this._chunkProcessorBuffer.mono.byteLength >=\n            this._chunkProcessorSize\n          ) {\n            this._chunkProcessor(this._chunkProcessorBuffer);\n            this._chunkProcessorBuffer = {\n              raw: new ArrayBuffer(0),\n              mono: new ArrayBuffer(0),\n            };\n          }\n        } else {\n          this._chunkProcessor(data);\n        }\n      }\n    };\n\n    const node = source.connect(processor);\n    const analyser = context.createAnalyser();\n    analyser.fftSize = 8192;\n    analyser.smoothingTimeConstant = 0.1;\n    node.connect(analyser);\n    if (this.outputToSpeakers) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'Warning: Output to speakers may affect sound quality,\\n' +\n          'especially due to system audio feedback preventative measures.\\n' +\n          'use only for debugging',\n      );\n      analyser.connect(context.destination);\n    }\n\n    this.source = source;\n    this.node = node;\n    this.analyser = analyser;\n    this.processor = processor;\n    return true;\n  }\n\n  /**\n   * Gets the current frequency domain data from the recording track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}\n   */\n  getFrequencies(\n    analysisType = 'frequency',\n    minDecibels = -100,\n    maxDecibels = -30,\n  ) {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    return AudioAnalysis.getFrequencies(\n      this.analyser,\n      this.sampleRate,\n      null,\n      analysisType,\n      minDecibels,\n      maxDecibels,\n    );\n  }\n\n  /**\n   * Pauses the recording\n   * Keeps microphone stream open but halts storage of audio\n   * @returns {Promise<true>}\n   */\n  async pause() {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    } else if (!this.recording) {\n      throw new Error('Already paused: please call .record() first');\n    }\n    if (this._chunkProcessorBuffer.raw.byteLength) {\n      this._chunkProcessor(this._chunkProcessorBuffer);\n    }\n    this.log('Pausing ...');\n    await this._event('stop');\n    this.recording = false;\n    return true;\n  }\n\n  /**\n   * Start recording stream and storing to memory from the connected audio source\n   * @param {(data: { mono: Int16Array; raw: Int16Array }) => any} [chunkProcessor]\n   * @param {number} [chunkSize] chunkProcessor will not be triggered until this size threshold met in mono audio\n   * @returns {Promise<true>}\n   */\n  async record(chunkProcessor = () => {}, chunkSize = 8192) {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    } else if (this.recording) {\n      throw new Error('Already recording: please call .pause() first');\n    } else if (typeof chunkProcessor !== 'function') {\n      throw new Error(`chunkProcessor must be a function`);\n    }\n    this._chunkProcessor = chunkProcessor;\n    this._chunkProcessorSize = chunkSize;\n    this._chunkProcessorBuffer = {\n      raw: new ArrayBuffer(0),\n      mono: new ArrayBuffer(0),\n    };\n    this.log('Recording ...');\n    await this._event('start');\n    this.recording = true;\n    return true;\n  }\n\n  /**\n   * Clears the audio buffer, empties stored recording\n   * @returns {Promise<true>}\n   */\n  async clear() {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    await this._event('clear');\n    return true;\n  }\n\n  /**\n   * Reads the current audio stream data\n   * @returns {Promise<{meanValues: Float32Array, channels: Array<Float32Array>}>}\n   */\n  async read() {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    this.log('Reading ...');\n    const result = await this._event('read');\n    return result;\n  }\n\n  /**\n   * Saves the current audio stream to a file\n   * @param {boolean} [force] Force saving while still recording\n   * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}\n   */\n  async save(force = false) {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    if (!force && this.recording) {\n      throw new Error(\n        'Currently recording: please call .pause() first, or call .save(true) to force',\n      );\n    }\n    this.log('Exporting ...');\n    const exportData = await this._event('export');\n    const packer = new WavPacker();\n    const result = packer.pack(this.sampleRate, exportData.audio);\n    return result;\n  }\n\n  /**\n   * Ends the current recording session and saves the result\n   * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}\n   */\n  async end() {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n\n    const _processor = this.processor;\n\n    this.log('Stopping ...');\n    await this._event('stop');\n    this.recording = false;\n    const tracks = this.stream.getTracks();\n    tracks.forEach((track) => track.stop());\n\n    this.log('Exporting ...');\n    const exportData = await this._event('export', {}, _processor);\n\n    this.processor.disconnect();\n    this.source.disconnect();\n    this.node.disconnect();\n    this.analyser.disconnect();\n    this.stream = null;\n    this.processor = null;\n    this.source = null;\n    this.node = null;\n\n    const packer = new WavPacker();\n    const result = packer.pack(this.sampleRate, exportData.audio);\n    return result;\n  }\n\n  /**\n   * Performs a full cleanup of WavRecorder instance\n   * Stops actively listening via microphone and removes existing listeners\n   * @returns {Promise<true>}\n   */\n  async quit() {\n    this.listenForDeviceChange(null);\n    if (this.processor) {\n      await this.end();\n    }\n    return true;\n  }\n}\n\nglobalThis.WavRecorder = WavRecorder;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}