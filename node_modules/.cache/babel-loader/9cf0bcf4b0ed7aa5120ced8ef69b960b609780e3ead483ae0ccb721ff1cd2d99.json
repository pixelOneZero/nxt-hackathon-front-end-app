{"ast":null,"code":"/**\n * EventHandler callback\n * @typedef {(event: {[key: string]: any}): void} EventHandlerCallbackType\n */\n\nconst sleep = t => new Promise(r => setTimeout(() => r(), t));\n\n/**\n * Inherited class for RealtimeAPI and RealtimeClient\n * Adds basic event handling\n * @class\n */\nexport class RealtimeEventHandler {\n  /**\n   * Create a new RealtimeEventHandler instance\n   * @returns {RealtimeEventHandler}\n   */\n  constructor() {\n    this.eventHandlers = {};\n    this.nextEventHandlers = {};\n  }\n\n  /**\n   * Clears all event handlers\n   * @returns {true}\n   */\n  clearEventHandlers() {\n    this.eventHandlers = {};\n    this.nextEventHandlers = {};\n    return true;\n  }\n\n  /**\n   * Listen to specific events\n   * @param {string} eventName The name of the event to listen to\n   * @param {EventHandlerCallbackType} callback Code to execute on event\n   * @returns {EventHandlerCallbackType}\n   */\n  on(eventName, callback) {\n    this.eventHandlers[eventName] = this.eventHandlers[eventName] || [];\n    this.eventHandlers[eventName].push(callback);\n    return callback;\n  }\n\n  /**\n   * Listen for the next event of a specified type\n   * @param {string} eventName The name of the event to listen to\n   * @param {EventHandlerCallbackType} callback Code to execute on event\n   * @returns {EventHandlerCallbackType}\n   */\n  onNext(eventName, callback) {\n    this.nextEventHandlers[eventName] = this.nextEventHandlers[eventName] || [];\n    this.nextEventHandlers[eventName].push(callback);\n    return callback;\n  }\n\n  /**\n   * Turns off event listening for specific events\n   * Calling without a callback will remove all listeners for the event\n   * @param {string} eventName\n   * @param {EventHandlerCallbackType} [callback]\n   * @returns {true}\n   */\n  off(eventName, callback) {\n    const handlers = this.eventHandlers[eventName] || [];\n    if (callback) {\n      const index = handlers.indexOf(callback);\n      if (index === -1) {\n        throw new Error(`Could not turn off specified event listener for \"${eventName}\": not found as a listener`);\n      }\n      handlers.splice(index, 1);\n    } else {\n      delete this.eventHandlers[eventName];\n    }\n    return true;\n  }\n\n  /**\n   * Turns off event listening for the next event of a specific type\n   * Calling without a callback will remove all listeners for the next event\n   * @param {string} eventName\n   * @param {EventHandlerCallbackType} [callback]\n   * @returns {true}\n   */\n  offNext(eventName, callback) {\n    const nextHandlers = this.nextEventHandlers[eventName] || [];\n    if (callback) {\n      const index = nextHandlers.indexOf(callback);\n      if (index === -1) {\n        throw new Error(`Could not turn off specified next event listener for \"${eventName}\": not found as a listener`);\n      }\n      nextHandlers.splice(index, 1);\n    } else {\n      delete this.nextEventHandlers[eventName];\n    }\n    return true;\n  }\n\n  /**\n   * Waits for next event of a specific type and returns the payload\n   * @param {string} eventName\n   * @param {number|null} [timeout]\n   * @returns {Promise<{[key: string]: any}|null>}\n   */\n  async waitForNext(eventName, timeout = null) {\n    const t0 = Date.now();\n    let nextEvent;\n    this.onNext(eventName, event => nextEvent = event);\n    while (!nextEvent) {\n      if (timeout) {\n        const t1 = Date.now();\n        if (t1 - t0 > timeout) {\n          return null;\n        }\n      }\n      await sleep(1);\n    }\n    return nextEvent;\n  }\n\n  /**\n   * Executes all events in the order they were added, with .on() event handlers executing before .onNext() handlers\n   * @param {string} eventName\n   * @param {any} event\n   * @returns {true}\n   */\n  dispatch(eventName, event) {\n    const handlers = [].concat(this.eventHandlers[eventName] || []);\n    for (const handler of handlers) {\n      handler(event);\n    }\n    const nextHandlers = [].concat(this.nextEventHandlers[eventName] || []);\n    for (const nextHandler of nextHandlers) {\n      nextHandler(event);\n    }\n    delete this.nextEventHandlers[eventName];\n    return true;\n  }\n}","map":{"version":3,"names":["sleep","t","Promise","r","setTimeout","RealtimeEventHandler","constructor","eventHandlers","nextEventHandlers","clearEventHandlers","on","eventName","callback","push","onNext","off","handlers","index","indexOf","Error","splice","offNext","nextHandlers","waitForNext","timeout","t0","Date","now","nextEvent","event","t1","dispatch","concat","handler","nextHandler"],"sources":["/Users/michaelmccarthy/Desktop/work_local/nxt_humans/projects/nxt-hackathon-front-end-app/node_modules/@openai/realtime-api-beta/lib/event_handler.js"],"sourcesContent":["/**\n * EventHandler callback\n * @typedef {(event: {[key: string]: any}): void} EventHandlerCallbackType\n */\n\nconst sleep = (t) => new Promise((r) => setTimeout(() => r(), t));\n\n/**\n * Inherited class for RealtimeAPI and RealtimeClient\n * Adds basic event handling\n * @class\n */\nexport class RealtimeEventHandler {\n  /**\n   * Create a new RealtimeEventHandler instance\n   * @returns {RealtimeEventHandler}\n   */\n  constructor() {\n    this.eventHandlers = {};\n    this.nextEventHandlers = {};\n  }\n\n  /**\n   * Clears all event handlers\n   * @returns {true}\n   */\n  clearEventHandlers() {\n    this.eventHandlers = {};\n    this.nextEventHandlers = {};\n    return true;\n  }\n\n  /**\n   * Listen to specific events\n   * @param {string} eventName The name of the event to listen to\n   * @param {EventHandlerCallbackType} callback Code to execute on event\n   * @returns {EventHandlerCallbackType}\n   */\n  on(eventName, callback) {\n    this.eventHandlers[eventName] = this.eventHandlers[eventName] || [];\n    this.eventHandlers[eventName].push(callback);\n    return callback;\n  }\n\n  /**\n   * Listen for the next event of a specified type\n   * @param {string} eventName The name of the event to listen to\n   * @param {EventHandlerCallbackType} callback Code to execute on event\n   * @returns {EventHandlerCallbackType}\n   */\n  onNext(eventName, callback) {\n    this.nextEventHandlers[eventName] = this.nextEventHandlers[eventName] || [];\n    this.nextEventHandlers[eventName].push(callback);\n    return callback;\n  }\n\n  /**\n   * Turns off event listening for specific events\n   * Calling without a callback will remove all listeners for the event\n   * @param {string} eventName\n   * @param {EventHandlerCallbackType} [callback]\n   * @returns {true}\n   */\n  off(eventName, callback) {\n    const handlers = this.eventHandlers[eventName] || [];\n    if (callback) {\n      const index = handlers.indexOf(callback);\n      if (index === -1) {\n        throw new Error(\n          `Could not turn off specified event listener for \"${eventName}\": not found as a listener`,\n        );\n      }\n      handlers.splice(index, 1);\n    } else {\n      delete this.eventHandlers[eventName];\n    }\n    return true;\n  }\n\n  /**\n   * Turns off event listening for the next event of a specific type\n   * Calling without a callback will remove all listeners for the next event\n   * @param {string} eventName\n   * @param {EventHandlerCallbackType} [callback]\n   * @returns {true}\n   */\n  offNext(eventName, callback) {\n    const nextHandlers = this.nextEventHandlers[eventName] || [];\n    if (callback) {\n      const index = nextHandlers.indexOf(callback);\n      if (index === -1) {\n        throw new Error(\n          `Could not turn off specified next event listener for \"${eventName}\": not found as a listener`,\n        );\n      }\n      nextHandlers.splice(index, 1);\n    } else {\n      delete this.nextEventHandlers[eventName];\n    }\n    return true;\n  }\n\n  /**\n   * Waits for next event of a specific type and returns the payload\n   * @param {string} eventName\n   * @param {number|null} [timeout]\n   * @returns {Promise<{[key: string]: any}|null>}\n   */\n  async waitForNext(eventName, timeout = null) {\n    const t0 = Date.now();\n    let nextEvent;\n    this.onNext(eventName, (event) => (nextEvent = event));\n    while (!nextEvent) {\n      if (timeout) {\n        const t1 = Date.now();\n        if (t1 - t0 > timeout) {\n          return null;\n        }\n      }\n      await sleep(1);\n    }\n    return nextEvent;\n  }\n\n  /**\n   * Executes all events in the order they were added, with .on() event handlers executing before .onNext() handlers\n   * @param {string} eventName\n   * @param {any} event\n   * @returns {true}\n   */\n  dispatch(eventName, event) {\n    const handlers = [].concat(this.eventHandlers[eventName] || []);\n    for (const handler of handlers) {\n      handler(event);\n    }\n    const nextHandlers = [].concat(this.nextEventHandlers[eventName] || []);\n    for (const nextHandler of nextHandlers) {\n      nextHandler(event);\n    }\n    delete this.nextEventHandlers[eventName];\n    return true;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}